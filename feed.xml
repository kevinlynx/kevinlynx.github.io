<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://kevinlynx.cc/</id><title>Loop in Codes</title><subtitle>Kevin Lynx's personal BLOG since 2011</subtitle> <updated>2022-09-17T14:09:05+08:00</updated> <author> <name>Kevin Lynx</name> <uri>https://kevinlynx.cc/</uri> </author><link rel="self" type="application/atom+xml" href="https://kevinlynx.cc/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://kevinlynx.cc/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 Kevin Lynx </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Kubernete APIServer Sample</title><link href="https://kevinlynx.cc/posts/kube_apiserver_sample/" rel="alternate" type="text/html" title="Kubernete APIServer Sample" /><published>2018-05-30T00:00:00+08:00</published> <updated>2018-05-30T00:00:00+08:00</updated> <id>https://kevinlynx.cc/posts/kube_apiserver_sample/</id> <content src="https://kevinlynx.cc/posts/kube_apiserver_sample/" /> <author> <name>Kevin Lynx</name> </author> <category term="弹性调度" /> <summary> kubernetes从apiserver中独立出来了一个项目：apiserver，可以基于这个库快速实现一个类似kubernetes apiserver的服务。 Generic library for building a Kubernetes aggregated API server. 如果直接阅读kubenetes的apiserver源码，会发现很多实现都位于这个项目中。kubenetes源码目录下还有个sample-apiserver，是用于示例如何使用这个库的。从这个sample可以更快速地了解kubernetes apiserver的实现，以及如何使用。 简单来说，这个apiserver库做了很多抽象，基本上，用户只需要描述自己的资源结构是怎样的，就可以构建出一个类似kubernetes的apiserver，具备资源多版本兼容能力，对外提供j... </summary> </entry> <entry><title>kubernetes网络相关总结</title><link href="https://kevinlynx.cc/posts/kube-network/" rel="alternate" type="text/html" title="kubernetes网络相关总结" /><published>2018-04-01T00:00:00+08:00</published> <updated>2018-04-01T00:00:00+08:00</updated> <id>https://kevinlynx.cc/posts/kube-network/</id> <content src="https://kevinlynx.cc/posts/kube-network/" /> <author> <name>Kevin Lynx</name> </author> <category term="弹性调度" /> <summary> 要理解kubernetes的网络模型涉及到的技术点比较多，网络上各个知识点讲得细的有很多，这里我就大概梳理下整个架构，方便顺着这个脉络深入。本文主要假设kubernetes使用docker+flannel实现。 整体上，了解kubernetes的网络模型，涉及到以下知识： linux网络及网络基础 docker网络模型 kubernetes网络需求，及flannel网络实现 最后大家就可以结合实例对照着学习。 Linux网络 先看几个概念，引用自Kubernetes网络原理及方案: 网络命名空间 Linux在网络栈中引入网络命名空间，将独立的网络协议栈隔离到不同的命令空间中，彼此间无法通信；docker利用这一特性，实现不同容器间的网络隔离 网桥 网桥是一个二层网络设备,通过网桥可以将linux支持的不同的端口连接起来,... </summary> </entry> <entry><title>使用Kubeadm在CentOS部署Kubernets 1.8.7</title><link href="https://kevinlynx.cc/posts/deploy-kubernetes/" rel="alternate" type="text/html" title="使用Kubeadm在CentOS部署Kubernets 1.8.7" /><published>2018-03-08T00:00:00+08:00</published> <updated>2018-03-08T00:00:00+08:00</updated> <id>https://kevinlynx.cc/posts/deploy-kubernetes/</id> <content src="https://kevinlynx.cc/posts/deploy-kubernetes/" /> <author> <name>Kevin Lynx</name> </author> <category term="弹性调度" /> <summary> 主要参考： 官方文档 如何在国内愉快的安装 Kubernetes kubernetes 1.8.7 国内安装(kubeadm) 建议都大致浏览下。这里我也是简单地记录，估计每个人遇到的细节问题不一样。 环境准备 我拿到手的环境docker已经ready： docker (alidocker-1.12.6.22) CentOS 7 上面博客提到的一些系统设置可以先做掉： cat &amp;lt;&amp;lt;EOF &amp;gt; /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sysctl -p /etc/sysctl.d/k8s.conf 其他一些设置： 防火墙最好关闭 swap最... </summary> </entry> <entry><title>基于Yarn的分布式应用调度器Slider</title><link href="https://kevinlynx.cc/posts/apache-slider/" rel="alternate" type="text/html" title="基于Yarn的分布式应用调度器Slider" /><published>2018-01-24T00:00:00+08:00</published> <updated>2018-01-24T00:00:00+08:00</updated> <id>https://kevinlynx.cc/posts/apache-slider/</id> <content src="https://kevinlynx.cc/posts/apache-slider/" /> <author> <name>Kevin Lynx</name> </author> <category term="弹性调度" /> <summary> Apache Hadoop Map-Reduce 框架为了解决规模增长问题，发展出了yarn。而yarn不仅解决Map-Reduce调度问题，还成为了一个通用的分布式应用调度服务。yarn中的一个创新是把各种不同应用的调度逻辑拆分到了一个称为Application Manager(以下简称AM)的角色中，从而让yarn自己变得更通用，同时解决调度性能问题。Apache Slider就是这其中的一个AM具体实现。但Slider进一步做了通用化，可以用于调度长运行(long-running)的分布式应用。 为了更好地理解Slider/Yarn，需要思考这样一个问题：在不用Slider/Yarn这种自动部署并管理应用的软件时，我们如何在一个网络环境中部署一个分布式应用？ 可能需要在目标物理机上创建虚拟容器，指定容器所用的CPU核数、内存数 到容器中下载或复制应用运行所需的所有... </summary> </entry> <entry><title>Python协程greenlet实现原理</title><link href="https://kevinlynx.cc/posts/greenlet/" rel="alternate" type="text/html" title="Python协程greenlet实现原理" /><published>2018-01-17T00:00:00+08:00</published> <updated>2018-01-17T00:00:00+08:00</updated> <id>https://kevinlynx.cc/posts/greenlet/</id> <content src="https://kevinlynx.cc/posts/greenlet/" /> <author> <name>Kevin Lynx</name> </author> <category term="python" /> <summary> greenlet是stackless Python中剥离出来的一个项目，可以作为官方CPython的一个扩展来使用，从而支持Python协程。gevent正是基于greenlet实现。 协程实现原理 实现协程主要是在协程切换时，将协程当前的执行上下文保存到协程关联的context中。在c/c++这种native程序中实现协程，需要将栈内容和CPU各个寄存器的内容保存起来。在Python这种VM中则有些不同。例如，在以下基于greenlet协程的python程序中： def foo(): bar() def bar(): a = 3 + 1 gr2.switch() def func(): pass gr1 = greenlet(foo) gr2 = greenlet(func) gr1.switch() 在bar中gr2.switch切... </summary> </entry> </feed>
