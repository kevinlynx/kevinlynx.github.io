<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Lisp实践：开发RSS阅读器" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="一、RSS阅读器的实现" /><meta property="og:description" content="一、RSS阅读器的实现" /><link rel="canonical" href="https://kevinlynx.cc/posts/lisp-rss/" /><meta property="og:url" content="https://kevinlynx.cc/posts/lisp-rss/" /><meta property="og:site_name" content="Loop in Codes" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2011-03-30T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Lisp实践：开发RSS阅读器" /><meta name="twitter:site" content="@kevinlynx" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2011-03-30T00:00:00+08:00","datePublished":"2011-03-30T00:00:00+08:00","description":"一、RSS阅读器的实现","headline":"Lisp实践：开发RSS阅读器","mainEntityOfPage":{"@type":"WebPage","@id":"https://kevinlynx.cc/posts/lisp-rss/"},"url":"https://kevinlynx.cc/posts/lisp-rss/"}</script><title>Lisp实践：开发RSS阅读器 | Loop in Codes</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Loop in Codes"><meta name="application-name" content="Loop in Codes"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="https://avatars.githubusercontent.com/u/789143?s=400&v=4" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Loop in Codes</a></div><div class="site-subtitle font-italic">Kevin Lynx's BLOG</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/kevinlynx" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/kevinlynx" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['kevinlynx','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>Lisp实践：开发RSS阅读器</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Lisp实践：开发RSS阅读器</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1301414400" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2011-03-30 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href="https://github.com/kevinlynx">Kevin Lynx</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2292 字"> <em>12 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="一rss阅读器的实现">一、RSS阅读器的实现</h1><p>RSS Reader的实现并不像它看上去那么复杂。当初在决定写这个作为Lisp练习时，甚至觉得 没有多少内容可做。其简单程度甚至用不了你启动一个慢速IDE的时间:D。对Lisp无兴趣的 TX只需要读完这一节即可，</p><h2 id="什么是rss阅读器"><span class="mr-2">什么是RSS阅读器?</span><a href="#什么是rss阅读器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>RSS在实现上，可以说是XML的又一次扩张式的应用。因为RSS最重要的东西就是一个XML文件 。RSS主要用于Web中的内容同步。例如我们写的博客，门户网站的新闻，都是内容。Web服 务器将这些内容组织成XML，然后我们通过一个客户端来解析这些XML，就可以在不用直接访 问网站的情况下获取信息： <img data-src="/assets/res/lisp_rss/rss-overview.png" alt="rss overview" data-proofer-ignore></p><p>RSS阅读器就是这样一个从Web服务器通过RSS（表现形式为XML）来获取信息内容的工具。它 可以被实现为一个独立的客户端程序，也可以实现为像Google Reader这种网页形式。后者 其核心功能其实是Google服务器在做，取得信息后再发给用户。</p><h2 id="rss文件"><span class="mr-2">RSS文件</span><a href="#rss文件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>上已提及，RSS的实现其实就是个XML文件。这个XML文件格式非常简单，例如:</p><figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version="1.0"?&gt;</span>
<span class="nt">&lt;rss</span> <span class="na">version=</span><span class="s">"2.0"</span><span class="nt">&gt;</span>
   <span class="nt">&lt;channel&gt;</span>
      <span class="nt">&lt;title&gt;</span>Liftoff News<span class="nt">&lt;/title&gt;</span>
      <span class="nt">&lt;link&gt;</span>http://liftoff.msfc.nasa.gov/<span class="nt">&lt;/link&gt;</span>
      <span class="nt">&lt;description&gt;</span>Liftoff to Space Exploration.<span class="nt">&lt;/description&gt;</span>
      <span class="nt">&lt;item&gt;</span>
         <span class="nt">&lt;title&gt;</span>Star City<span class="nt">&lt;/title&gt;</span>
         <span class="nt">&lt;link&gt;</span>http://liftoff.msfc.nasa.gov/news/2003/news-starcity.asp<span class="nt">&lt;/link&gt;</span>
         <span class="nt">&lt;description&gt;</span>Oh no, you wrote another blog!<span class="nt">&lt;/description&gt;</span>
      <span class="nt">&lt;/item&gt;</span>
    <span class="nt">&lt;/channel&gt;</span>
<span class="nt">&lt;/rss&gt;</span></code></pre></figure><p>我们身边到处都是RSS文件，例如 <a href="http://www.cppblog.com/rss.aspx">http://www.cppblog.com/rss.aspx</a> 。RSS文件的框架大 致为:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>&lt;rss&gt;
    &lt;channel&gt;
        &lt;item&gt;
        &lt;/item&gt;
        &lt;item&gt;
        &lt;/item&gt;
        ...
    &lt;/channel&gt;
&lt;/rss&gt;
</pre></table></code></div></div><p>对，其框架就是这样，一个channel节点，其下若干个item节点。举例来说， <strong>CPPBLOG首页就 是一个channel，该channel下有若干原创文章，每篇文章就是一个item。</strong> 无论是channel ，还是item，都会有很多属性，例如title/description/link，有些属性是RSS规范里要求 必须有的，有的是可选的。</p><h2 id="交互过程"><span class="mr-2">交互过程</span><a href="#交互过程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>那么，服务器和客户端是如何交互的呢？首先，服务器上的程序针对其某个页面，生成对应 的RSS文件。这个RSS文件基本上是有固定的URL的。客户端每次获取内容时，就从这个固定 的URL获取这个RSS文件。客户端获取到这个RSS文件后，解析之，再呈现给用户。这就是整 个过程。这个过程中客户端与服务器的交互，全部是正常的HTTP请求。</p><p>而RSS阅读器，如果做得足够简单，则只需要从指定的地方获取到RSS文件，然后解析这个 XML文件，然后以相对友好的形式显示即可。</p><h2 id="扩展"><span class="mr-2">扩展</span><a href="#扩展" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>虽然RSS阅读器在核心功能上很简单，但是作为一个可以使用的工具，依然有很多功能点需 要实现。基本功能包括：</p><ul><li>记录用户关注的RSS<li>缓存某个RSS过去一段时间更新的内容<li>对HTTP回应的处理，最重要的就是重定向处理</ul><p>我们还可以做很多扩展，例如Google Reader之类的在线RSS阅读器。这些阅读器的RSS抓取 功能做在服务器端，它们除了上面提到的基础功能外，还会包含内容分类，给内容打一些 标签，分析用户的订阅习惯然后推荐类似的内容等等。</p><h1 id="二lisp实现">二、Lisp实现</h1><p>本节描述在Lisp中实现上文的内容。主要包括： <strong>通过HTTP请求获取到RSS文件、解析RSS文件 。</strong></p><h2 id="获取rss文件"><span class="mr-2">获取RSS文件</span><a href="#获取rss文件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Lisp虽然历史悠久，但其扩展库标准却做得很拙劣。偏应用级的扩展库要么由编译器实现提 供，要么就得自己在网上找。一方面使用者希望库使用起来方便，另一方面库开发者在跨编 译器实现方面也头疼不已。所幸现在有了quick lisp，安装第三方库就像Ubuntu里安装软件 一样简单（大部分）。</p><p>socket支持就是面临的第一个问题。不过我这里并不考虑跨编译器实现的问题，直接使用 SBCL里的socket接口。</p><p>要获取RSS文件，只需要连接Web服务器，发起HTTP的GET请求即可。当然，建立TCP连接，组 建HTTP请求包，就不是这里的讨论了。我们还是拿CPPBLOG首页的RSS为例，该RSS的URL为:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>http://www.cppblog.com/rss.aspx
</pre></table></code></div></div><p>拆分一下，得到host为www.cppblog.com（即我们要connect的地址），rss的uri为 /rss.aspx（即HTTP请求里的文件URI），于是建立HTTP请求包:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>GET /rss.aspx HTTP/1.0
Host: www.cppblog.com
</pre></table></code></div></div><p>关于HTTP请求的一些基础知识，可以参考我很早前写的一篇博客：&lt;<a href="http://www.cppblog.com/kevinlynx/archive/2008/07/30/57521.aspx">实现自己的http服务器</a>&gt;。 正常情况下，Web服务器就会返回RSS的文件内容。然后我们就可以继续解析。</p><h2 id="解析rss"><span class="mr-2">解析RSS</span><a href="#解析rss" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>RSS本身是一个XML格式的文件。之前连接Web服务器发起HTTP请求没有用到第三方库，但是 解析XML文件不是几十来行代码能搞定的事情，所以这里需要选用一个第三方库。</p><p>我用的是s-xml，这个库在我之前的 <a href="http://www.cppblog.com/kevinlynx/archive/2011/03/13/141713.aspx">关于Lisp的文章</a> 中提到过。s-xml与我之前在C++ 领域见到的XML解析库最大的不同点在于，它提供的API是基于事件模式的。意思是说，你不 要去查询某个element的值是多少，当我解析到的时候会告诉你。事件模式的编程方式自然 离不开回调函数:</p><figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">s-xml:start-parse-xml</span> 
  <span class="nc">stream</span>
  <span class="p">(</span><span class="nb">make-instance</span> <span class="ss">'s-xml:xml-parser-state</span>
                 <span class="ss">:new-element-hook</span> <span class="nf">#'</span><span class="nv">decode-rss-new-element</span>
                 <span class="ss">:finish-element-hook</span> <span class="nf">#'</span><span class="nv">decode-rss-finish-element</span>
                 <span class="ss">:text-hook</span> <span class="nf">#'</span><span class="nv">decode-rss-text</span><span class="p">))</span><span class="err">)</span></code></pre></figure><p>与s-xml交互的也就是上面代码里提到的三个函数：new-element-hook, finish-element-hook , text-hook。这种类型的接口导致解析代码大量减少，但不利于理解。我们要在整个解析 过程中传递数据，需要通过与s-xml交互的函数参数（当然不会蠢到去用全局变量）。</p><p>解析过程中通过往函数参数指定的对象身上塞数据完成，整个解析实现也就几十行代码。 文章尾可下载代码看看。</p><h2 id="显示出来"><span class="mr-2">显示出来</span><a href="#显示出来" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>通过上面两步，我们得到了RSS文件、解析出了具体内容，最后一步就是呈现出来看看。RSS 文件里每个Item都是一篇文章（新闻之类），这个文章内容可直接包含HTML标记，说白了， 这些内容就是直接的HTML内容。要显示这些内容，最简单的方法就是把一个RSS转换成一种 简单的HTML文件，以供阅读。</p><p>这里就涉及到HTML generator，几乎所有的Lisper都会写一个HTML产生器（库）（虽然目前 我还没写）。这种库的作用就是方便地输出HTML文件。</p><p>Lisp相对于其他语言很大的一个特点，或者说是优点，就是其语言本身的扩展能力。这种扩 展不是简单的添加几个函数，也不是类，而是提供一些就像语言本身提供的特殊操作符一样 的东西。而HTML generator正是这种东西大放异彩的地方。这种感觉有点像在C++中通过模 板造出各种增强语言特性的东西一样（例如boost/loki）。</p><p>因为我这里只是输出简单的HTML文件，何况我对HTML的标记了解的也不多，也懒得再花经历 。所以我暂时也就将就了些土方法:</p><figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">with-output-to-string</span> <span class="p">(</span><span class="nc">stream</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">channel</span> <span class="p">(</span><span class="nv">rss-channel</span> <span class="nv">rss</span><span class="p">)))</span> <span class="c1">;取出channel对象</span>
   <span class="p">(</span><span class="nb">format</span> <span class="nc">stream</span> <span class="s">"&lt;html&gt;&lt;head&gt;&lt;title&gt;~a&lt;/title&gt;&lt;/head&gt;"</span>
           <span class="p">(</span><span class="nv">get-property</span> <span class="nv">channel</span> <span class="ss">:|title|</span><span class="p">))</span> <span class="c1">;取出channel的title</span></code></pre></figure><p>最后组合一些接口，即可将整个过程联系起来，导出html文件:</p><figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">cl-rss-test:test-rss-http</span> <span class="ss">:uri</span> <span class="s">"/news/newshot/hotnewsrss.xml"</span> 
                           <span class="ss">:host</span> <span class="s">"cd.qq.com"</span><span class="p">)</span></code></pre></figure><p>然后在浏览器里查看，如图:</p><p><img data-src="/assets/res/lisp_rss/screenshot.png" alt="sample" data-proofer-ignore></p><h2 id="其他"><span class="mr-2">其他</span><a href="#其他" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>当一些代码可以工作起来的时候，就可以着手测试这批代码。然后我就用这个工具测试我 Google Reader里订阅的一些RSS。最大的问题，就是关于HTTP重定向的问题。</p><p>当服务器返回301或者302的错误信息时（HTTP回应），就标示请求的URI被移动到了其他地 方，客户端需要访问新的地址。这个其实查查 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">HTTP的规范</a> 就可以轻易解决。重定向时， 新的URI被指定在Response Header里的Location域，取出来发起第二次请求即可。</p><p><a href="http://www.cppblog.com/Files/kevinlynx/cl-rss.tar.gz">下载代码</a></p><h1 id="参考文档">参考文档</h1><ul><li>HTTP规范: <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http://www.w3.org/Protocols/rfc2616/rfc2616.html</a><li>RSS2.0规范: <a href="http://feed2.w3.org/docs/rss2.html">http://feed2.w3.org/docs/rss2.html</a></ul><p>;;EOF;;</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/lisp/'>lisp</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/lisp/" class="post-tag no-text-decoration" >lisp</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Lisp%E5%AE%9E%E8%B7%B5%EF%BC%9A%E5%BC%80%E5%8F%91RSS%E9%98%85%E8%AF%BB%E5%99%A8+-+Loop+in+Codes&url=https%3A%2F%2Fkevinlynx.cc%2Fposts%2Flisp-rss%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Lisp%E5%AE%9E%E8%B7%B5%EF%BC%9A%E5%BC%80%E5%8F%91RSS%E9%98%85%E8%AF%BB%E5%99%A8+-+Loop+in+Codes&u=https%3A%2F%2Fkevinlynx.cc%2Fposts%2Flisp-rss%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fkevinlynx.cc%2Fposts%2Flisp-rss%2F&text=Lisp%E5%AE%9E%E8%B7%B5%EF%BC%9A%E5%BC%80%E5%8F%91RSS%E9%98%85%E8%AF%BB%E5%99%A8+-+Loop+in+Codes" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/tips/">tips</a> <a class="post-tag" href="/tags/c-c/">c/c++</a> <a class="post-tag" href="/tags/erlang/">erlang</a> <a class="post-tag" href="/tags/dht/">dht</a> <a class="post-tag" href="/tags/lisp/">lisp</a> <a class="post-tag" href="/tags/lua/">lua</a> <a class="post-tag" href="/tags/p2p/">p2p</a> <a class="post-tag" href="/tags/magnet/">magnet</a> <a class="post-tag" href="/tags/octopress/">octopress</a> <a class="post-tag" href="/tags/ruby/">ruby</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/lisp-writer/"><div class="card-body"> <em class="small" data-ts="1299945600" data-df="YYYY-MM-DD" > 2011-03-13 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>用lisp开发博客客户端</h3><div class="text-muted small"><p> 最近一直在学习Lisp这门语言。回头一看，基本上接近1个月了。刚开始接触Lisp是因为看 了&amp;lt;Lisp本质&amp;gt;，然后我发现有很多人宗教般地忠诚这门语言，于是就来了兴趣。 当然并不是每次因为某篇写得很geek技术文章就去学习某个新的技术点。一个月时间对我来 说还是很珍贵了。但是Lisp绝对是大部分程序员都值得一学的语言（就像Haskell一样）。 我能给出的简单理由包括： ...</p></div></div></a></div><div class="card"> <a href="/posts/lisp-symbol/"><div class="card-body"> <em class="small" data-ts="1300636800" data-df="YYYY-MM-DD" > 2011-03-21 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Lisp一瞥：增强型变量Symbol</h3><div class="text-muted small"><p> 变量，是所有编程语言里都有的语法概念。在C/C++中，变量用于标示一个内存地址，而变 量名则在语法层面上代表这个地址。当链接器最终链接我们的程序时，就将这些名字替换 为实际的地址。在其他语言中，变量虽然或多或少有其他不同的含义，但也大致如此。 Lisp中的变量也差不多这样，但若将variable和Lisp中的 symbol 放在一起，则多少会 带来些困惑。 Lisp中的“变量” 很多教...</p></div></div></a></div><div class="card"> <a href="/posts/build-blog-by-lisp/"><div class="card-body"> <em class="small" data-ts="1317225600" data-df="YYYY-MM-DD" > 2011-09-29 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>使用Lisp搭建独立博客</h3><div class="text-muted small"><p> 本文描述如何使用Lisp工具集搭建一个完整的个人博客站点。一个搭建好的例子站点可以参看我的个人博客：http://codemacro.com。 要搭建一个独立博客，需要两方面的支持。一是博客软件，二是根据选择的博客软件取得必须的“硬件“。例如我这里使用的是Lisp工具集，就需要一个可以完全控制的服务器，所以这里我需要一个VPS。当然，购买一个合适的域名也是必须的。以下将针对这些内容做描述。...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/lisp-symbol/" class="btn btn-outline-primary" prompt="上一篇"><p>Lisp一瞥：增强型变量Symbol</p></a> <a href="/posts/module-level/" class="btn btn-outline-primary" prompt="下一篇"><p>浅谈代码分层：构建模块化程序</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "kevinlynx/kevinlynx.github.io", "data-repo-id": "R_kgDOIAJnIQ", "data-category": "General", "data-category-id": "DIC_kwDOIAJnIc4CReqT", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "top", "data-lang": "zh-CN", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/kevinlynx">Kevin Lynx</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/tips/">tips</a> <a class="post-tag" href="/tags/c-c/">c/c++</a> <a class="post-tag" href="/tags/erlang/">erlang</a> <a class="post-tag" href="/tags/dht/">dht</a> <a class="post-tag" href="/tags/lisp/">lisp</a> <a class="post-tag" href="/tags/lua/">lua</a> <a class="post-tag" href="/tags/p2p/">p2p</a> <a class="post-tag" href="/tags/magnet/">magnet</a> <a class="post-tag" href="/tags/octopress/">octopress</a> <a class="post-tag" href="/tags/ruby/">ruby</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">发现新版本的内容。</p><button type="button" class="btn btn-primary" aria-label="Update"> 更新 </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
