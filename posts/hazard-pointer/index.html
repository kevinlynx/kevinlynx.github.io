<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="并行编程中的内存回收Hazard Pointer" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="接上篇使用RCU技术实现读写线程无锁，在没有GC机制的语言中，要实现Lock free的算法，就免不了要自己处理内存回收的问题。" /><meta property="og:description" content="接上篇使用RCU技术实现读写线程无锁，在没有GC机制的语言中，要实现Lock free的算法，就免不了要自己处理内存回收的问题。" /><link rel="canonical" href="https://kevinlynx.cc/posts/hazard-pointer/" /><meta property="og:url" content="https://kevinlynx.cc/posts/hazard-pointer/" /><meta property="og:site_name" content="Loop in Codes" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2015-05-03T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="并行编程中的内存回收Hazard Pointer" /><meta name="twitter:site" content="@kevinlynx" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2015-05-03T00:00:00+08:00","datePublished":"2015-05-03T00:00:00+08:00","description":"接上篇使用RCU技术实现读写线程无锁，在没有GC机制的语言中，要实现Lock free的算法，就免不了要自己处理内存回收的问题。","headline":"并行编程中的内存回收Hazard Pointer","mainEntityOfPage":{"@type":"WebPage","@id":"https://kevinlynx.cc/posts/hazard-pointer/"},"url":"https://kevinlynx.cc/posts/hazard-pointer/"}</script><title>并行编程中的内存回收Hazard Pointer | Loop in Codes</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Loop in Codes"><meta name="application-name" content="Loop in Codes"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="https://avatars.githubusercontent.com/u/789143?s=400&v=4" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Loop in Codes</a></div><div class="site-subtitle font-italic">Kevin Lynx's BLOG</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/kevinlynx" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/kevinlynx" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['kevinlynx','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>并行编程中的内存回收Hazard Pointer</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>并行编程中的内存回收Hazard Pointer</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1430582400" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2015-05-03 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href="https://github.com/kevinlynx">Kevin Lynx</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1706 字"> <em>9 分钟</em>阅读</span></div></div></div><div class="post-content"><p>接上篇<a href="http://codemacro.com/2015/04/19/rw_thread_gc/">使用RCU技术实现读写线程无锁</a>，在没有GC机制的语言中，要实现Lock free的算法，就免不了要自己处理内存回收的问题。</p><p>Hazard Pointer是另一种处理这个问题的算法，而且相比起来不但简单，功能也很强大。<a href="http://blog.csdn.net/pongba/article/details/589864">锁无关的数据结构与Hazard指针</a>中讲得很好，<a href="http://en.wikipedia.org/wiki/Hazard_pointer">Wikipedia Hazard pointer</a>也描述得比较清楚，所以我这里就不讲那么细了。</p><p>一个简单的实现可以参考<a href="https://github.com/kevinlynx/lockfree-list/blob/master/haz_ptr.c">我的github haz_ptr.c</a></p><h2 id="原理"><span class="mr-2">原理</span><a href="#原理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>基本原理无非也是读线程对指针进行标识，指针(指向的内存)要释放时都会缓存起来延迟到确认没有读线程了才对其真正释放。</p><p><code class="language-plaintext highlighter-rouge">&lt;Lock-Free Data Structures with Hazard Pointers&gt;</code>中的描述：</p><blockquote><p>Each reader thread owns a single-writer/multi-reader shared pointer called “hazard pointer.” When a reader thread assigns the address of a map to its hazard pointer, it is basically announcing to other threads (writers), “I am reading this map. You can replace it if you want, but don’t change its contents and certainly keep your deleteing hands off it.”</p></blockquote><p>关键的结构包括：<code class="language-plaintext highlighter-rouge">Hazard pointer</code>、<code class="language-plaintext highlighter-rouge">Thread Free list</code></p><p><code class="language-plaintext highlighter-rouge">Hazard pointer</code>：一个读线程要使用一个指针时，就会创建一个Hazard pointer包装这个指针。一个Hazard pointer会被一个线程写，多个线程读。</p><figure class="highlight"><pre><code class="language-c--" data-lang="c++">    <span class="k">struct</span> <span class="nc">HazardPointer</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">real_ptr</span><span class="p">;</span> <span class="c1">// 包装的指针</span>
        <span class="p">...</span> <span class="c1">// 不同的实现有不同的成员</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">HazardPointer</span> <span class="o">*</span><span class="n">hp</span> <span class="o">=</span> <span class="n">accquire</span><span class="p">(</span><span class="n">_real_ptr</span><span class="p">);</span>
        <span class="p">...</span> <span class="c1">// use _real_ptr</span>
        <span class="n">release</span><span class="p">(</span><span class="n">hp</span><span class="p">);</span>
    <span class="p">}</span></code></pre></figure><p><code class="language-plaintext highlighter-rouge">Thread Free List</code>：每个线程都有一个这样的列表，保存着将要释放的指针列表，这个列表仅对应的线程读写</p><figure class="highlight"><pre><code class="language-c--" data-lang="c++">    <span class="kt">void</span> <span class="nf">defer_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_free_list</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="p">}</span></code></pre></figure><p>当某个线程要尝试释放Free List中的指针时，例如指针<code class="language-plaintext highlighter-rouge">ptr</code>，就检查所有其他线程使用的Hazard pointer，检查是否存在包装了<code class="language-plaintext highlighter-rouge">ptr</code>的Hazard pointer，如果没有则说明没有读线程正在使用<code class="language-plaintext highlighter-rouge">ptr</code>，可以安全释放<code class="language-plaintext highlighter-rouge">ptr</code>。</p><figure class="highlight"><pre><code class="language-c--" data-lang="c++">    <span class="kt">void</span> <span class="nf">gc</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="n">ptr</span> <span class="n">in</span> <span class="n">_free_list</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">conflict</span> <span class="o">=</span> <span class="nb">false</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">hp</span> <span class="n">in</span> <span class="n">_all_hazard_pointers</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">_real_ptr</span> <span class="o">==</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">confilict</span> <span class="o">=</span> <span class="nb">true</span>
                    <span class="k">break</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">conflict</span><span class="p">)</span>
                <span class="k">delete</span> <span class="n">ptr</span>
        <span class="p">}</span>
    <span class="p">}</span></code></pre></figure><p>以上，其实就是<code class="language-plaintext highlighter-rouge">Hazard Pointer</code>的主要内容。</p><h2 id="hazard-pointer的管理"><span class="mr-2">Hazard Pointer的管理</span><a href="#hazard-pointer的管理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>上面的代码中没有提到<code class="language-plaintext highlighter-rouge">_all_hazard_pointers</code>及<code class="language-plaintext highlighter-rouge">accquire</code>的具体实现，这就是Hazard Pointer的管理问题。</p><p>《锁无关的数据结构与Hazard指针》文中创建了一个Lock free的链表来表示这个全局的Hazard Pointer List。每个Hazard Pointer有一个成员标识其是否可用。这个List中也就保存了已经被使用的Hazard Pointer集合和未被使用的Hazard Pointer集合，当所有Hazard Pointer都被使用时，就会新分配一个加进这个List。当读线程不使用指针时，需要归还Hazard Pointer，直接设置可用成员标识即可。要<code class="language-plaintext highlighter-rouge">gc()</code>时，就直接遍历这个List。</p><p>要实现一个Lock free的链表，并且仅需要实现头插入，还是非常简单的。本身Hazard Pointer标识某个指针时，都是用了后立即标识，所以这个实现直接支持了动态线程，支持线程的挂起等。</p><p>在<a href="https://code.google.com/p/nbds/">nbds</a>项目中也有一个Hazard Pointer的实现，相对要弱一点。它为每个线程都设置了自己的Hazard Pointer池，写线程要释放指针时，就访问所有其他线程的Hazard Pointer池。</p><figure class="highlight"><pre><code class="language-c--" data-lang="c++">    <span class="k">typedef</span> <span class="k">struct</span> <span class="nc">haz_local</span> <span class="p">{</span>
        <span class="c1">// Free List</span>
        <span class="n">pending_t</span> <span class="o">*</span><span class="n">pending</span><span class="p">;</span> <span class="c1">// to be freed</span>
        <span class="kt">int</span> <span class="n">pending_size</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">pending_count</span><span class="p">;</span>

        <span class="c1">// Hazard Pointer 池，动态和静态两种</span>
        <span class="n">haz_t</span> <span class="n">static_haz</span><span class="p">[</span><span class="n">STATIC_HAZ_PER_THREAD</span><span class="p">];</span>

        <span class="n">haz_t</span> <span class="o">**</span><span class="n">dynamic</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">dynamic_size</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">dynamic_count</span><span class="p">;</span>

    <span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="n">CACHE_LINE_SIZE</span><span class="p">)))</span> <span class="n">haz_local_t</span><span class="p">;</span>

    <span class="k">static</span> <span class="n">haz_local_t</span> <span class="n">haz_local_</span><span class="p">[</span><span class="n">MAX_NUM_THREADS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span></code></pre></figure><p>每个线程当然就涉及到<code class="language-plaintext highlighter-rouge">haz_local_</code>索引(ID)的分配，就像<a href="http://codemacro.com/2015/04/19/rw_thread_gc/">使用RCU技术实现读写线程无锁</a>中的一样。这个实现为了支持线程动态创建，就需要一套线程ID的重用机制，相对复杂多了。</p><h2 id="附录"><span class="mr-2">附录</span><a href="#附录" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>最后，附上一些并行编程中的一些概念。</p><h3 id="lock-free--wait-free"><span class="mr-2">Lock Free &amp; Wait Free</span><a href="#lock-free--wait-free" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>常常看到<code class="language-plaintext highlighter-rouge">Lock Free</code>和<code class="language-plaintext highlighter-rouge">Wait Free</code>的概念，这些概念用于衡量一个系统或者说一段代码的并行级别，并行级别可参考<a href="http://www.cnblogs.com/jiayy/p/3246167.html">并行编程——并发级别</a>。总之Wait Free是一个比Lock Free更牛逼的级别。</p><p>我自己的理解，例如《锁无关的数据结构与Hazard指针》中实现的Hazard Pointer链表就可以说是Lock Free的，注意它在插入新元素到链表头时，因为使用<code class="language-plaintext highlighter-rouge">CAS</code>，总免不了一个busy loop，有这个特征的情况下就算是<code class="language-plaintext highlighter-rouge">Lock Free</code>，虽然没锁，但某个线程的执行情况也受其他线程的影响。</p><p>相对而言，<code class="language-plaintext highlighter-rouge">Wait Free</code>则是每个线程的执行都是独立的，例如《锁无关的数据结构与Hazard指针》中的<code class="language-plaintext highlighter-rouge">Scan</code>函数。<code class="language-plaintext highlighter-rouge">“每个线程的执行时间都不依赖于其它任何线程的行为”</code></p><blockquote><p>锁无关(Lock-Free)意味着系统中总存在某个线程能够得以继续执行；而等待无关(Wait-Free)则是一个更强的条件，它意味着所有线程都能往下进行。</p></blockquote><h3 id="aba问题"><span class="mr-2">ABA问题</span><a href="#aba问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在实现<code class="language-plaintext highlighter-rouge">Lock Free</code>算法的过程中，总是要使用<code class="language-plaintext highlighter-rouge">CAS</code>原语的，而<code class="language-plaintext highlighter-rouge">CAS</code>就会带来<code class="language-plaintext highlighter-rouge">ABA</code>问题。</p><blockquote><p>在进行CAS操作的时候，因为在更改V之前，CAS主要询问“V的值是否仍然为A”，所以在第一次读取V之后以及对V执行CAS操作之前，如果将值从A改为B，然后再改回A，会使基于CAS的算法混乱。在这种情况下，CAS操作会成功。这类问题称为ABA问题。</p></blockquote><p><a href="http://en.wikipedia.org/wiki/Hazard_pointer">Wiki Hazard Pointer</a>提到了一个ABA问题的好例子：在一个Lock free的栈实现中，现在要出栈，栈里的元素是<code class="language-plaintext highlighter-rouge">[A, B, C]</code>，<code class="language-plaintext highlighter-rouge">head</code>指向栈顶，那么就有<code class="language-plaintext highlighter-rouge">compare_and_swap(target=&amp;head, newvalue=B, expected=A)</code>。但是在这个操作中，其他线程把<code class="language-plaintext highlighter-rouge">A</code> <code class="language-plaintext highlighter-rouge">B</code>都出栈，且删除了<code class="language-plaintext highlighter-rouge">B</code>，又把<code class="language-plaintext highlighter-rouge">A</code>压入栈中，即<code class="language-plaintext highlighter-rouge">[A, C]</code>。那么前一个线程的<code class="language-plaintext highlighter-rouge">compare_and_swap</code>能够成功，此时<code class="language-plaintext highlighter-rouge">head</code>指向了一个已经被删除的<code class="language-plaintext highlighter-rouge">B</code>。stackoverflow上也有个例子 <a href="http://stackoverflow.com/questions/14535948/real-world-examples-for-aba-in-multithreading">Real-world examples for ABA in multithreading</a></p><blockquote><p>对于CAS产生的这个ABA问题，通常的解决方案是采用CAS的一个变种DCAS。DCAS，是对于每一个V增加一个引用的表示修改次数的标记符。对于每个V，如果引用修改了一次，这个计数器就加1。然后再这个变量需要update的时候，就同时检查变量的值和计数器的值。</p></blockquote><p>但也早有人提出<code class="language-plaintext highlighter-rouge">DCAS</code>也不是<a href="http://people.csail.mit.edu/shanir/publications/DCAS.pdf">ABA problem 的银弹</a>。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/c-c/'>c/c++</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/hazard/" class="post-tag no-text-decoration" >hazard</a> <a href="/tags/pointer/" class="post-tag no-text-decoration" >pointer</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6Hazard+Pointer+-+Loop+in+Codes&url=https%3A%2F%2Fkevinlynx.cc%2Fposts%2Fhazard-pointer%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6Hazard+Pointer+-+Loop+in+Codes&u=https%3A%2F%2Fkevinlynx.cc%2Fposts%2Fhazard-pointer%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fkevinlynx.cc%2Fposts%2Fhazard-pointer%2F&text=%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6Hazard+Pointer+-+Loop+in+Codes" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/tips/">tips</a> <a class="post-tag" href="/tags/c-c/">c/c++</a> <a class="post-tag" href="/tags/erlang/">erlang</a> <a class="post-tag" href="/tags/dht/">dht</a> <a class="post-tag" href="/tags/lisp/">lisp</a> <a class="post-tag" href="/tags/lua/">lua</a> <a class="post-tag" href="/tags/p2p/">p2p</a> <a class="post-tag" href="/tags/magnet/">magnet</a> <a class="post-tag" href="/tags/octopress/">octopress</a> <a class="post-tag" href="/tags/ruby/">ruby</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/multi-inherit-void/"><div class="card-body"> <em class="small" data-ts="1304092800" data-df="YYYY-MM-DD" > 2011-04-30 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>多重继承和void*的糗事</h3><div class="text-muted small"><p> C++为了兼容C，导致了不少语言阴暗面。Bjarne Stroustrup在&amp;lt;D&amp;amp;E&amp;gt;一书里也常为此表现出无奈。另一方面，强制转换也是C++的一大诟病。但是，因为我们的应用环境总是那么“不 纯”，所以也就常常导致各种问题。 本文即描述了一个关于强制转换带来的问题。这个问题几年前我曾遇到过(&amp;lt;多线程下vc2003,vc2005对虚函数表处理的BUG？&amp;gt;)，当时...</p></div></div></a></div><div class="card"> <a href="/posts/write-cpp-like-fp/"><div class="card-body"> <em class="small" data-ts="1343639460" data-df="YYYY-MM-DD" > 2012-07-30 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>像写函数式语言代码一样写C++</h3><div class="text-muted small"><p> 忘记最早接触函数式编程语言是什么时候了，也忘记接触的第一门函数式语言是哪一门。断断续续接触过好几种函数式语言（当然都算不纯的，ruby/lisp不算纯吧），这些语言的思想在潜移默化中多多少少对我有所影响。 我是个C++程序员，我不知道我平时写的都是些什么代码。最让人印象深刻就是我会经常写遍历STL容器的代码，是经常，这样的遍历你可能也不陌生： for (ListType::iterato...</p></div></div></a></div><div class="card"> <a href="/posts/memcmp-on-copy-value/"><div class="card-body"> <em class="small" data-ts="1345174620" data-df="YYYY-MM-DD" > 2012-08-17 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>使用memcmp比较两个变量结果一定吗？</h3><div class="text-muted small"><p> 参考Is using memcmp on array of int strictly conforming? 以下代码一定会输出ok吗？ #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; struct S { int array[2]; }; int main () { struct S a = { { 1, 2 } }; ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/rw_thread_gc/" class="btn btn-outline-primary" prompt="上一篇"><p>使用RCU技术实现读写线程无锁</p></a> <a href="/posts/lock_free_list/" class="btn btn-outline-primary" prompt="下一篇"><p>无锁有序链表的实现</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "kevinlynx/kevinlynx.github.io", "data-repo-id": "R_kgDOIAJnIQ", "data-category": "General", "data-category-id": "DIC_kwDOIAJnIc4CReqT", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "top", "data-lang": "zh-CN", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/kevinlynx">Kevin Lynx</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/tips/">tips</a> <a class="post-tag" href="/tags/c-c/">c/c++</a> <a class="post-tag" href="/tags/erlang/">erlang</a> <a class="post-tag" href="/tags/dht/">dht</a> <a class="post-tag" href="/tags/lisp/">lisp</a> <a class="post-tag" href="/tags/lua/">lua</a> <a class="post-tag" href="/tags/p2p/">p2p</a> <a class="post-tag" href="/tags/magnet/">magnet</a> <a class="post-tag" href="/tags/octopress/">octopress</a> <a class="post-tag" href="/tags/ruby/">ruby</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">发现新版本的内容。</p><button type="button" class="btn btn-primary" aria-label="Update"> 更新 </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
