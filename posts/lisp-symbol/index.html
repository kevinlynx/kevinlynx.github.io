<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Lisp一瞥：增强型变量Symbol" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="变量，是所有编程语言里都有的语法概念。在C/C++中，变量用于标示一个内存地址，而变 量名则在语法层面上代表这个地址。当链接器最终链接我们的程序时，就将这些名字替换 为实际的地址。在其他语言中，变量虽然或多或少有其他不同的含义，但也大致如此。" /><meta property="og:description" content="变量，是所有编程语言里都有的语法概念。在C/C++中，变量用于标示一个内存地址，而变 量名则在语法层面上代表这个地址。当链接器最终链接我们的程序时，就将这些名字替换 为实际的地址。在其他语言中，变量虽然或多或少有其他不同的含义，但也大致如此。" /><link rel="canonical" href="https://kevinlynx.cc/posts/lisp-symbol/" /><meta property="og:url" content="https://kevinlynx.cc/posts/lisp-symbol/" /><meta property="og:site_name" content="Loop in Codes" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2011-03-21T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Lisp一瞥：增强型变量Symbol" /><meta name="twitter:site" content="@kevinlynx" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2011-03-21T00:00:00+08:00","datePublished":"2011-03-21T00:00:00+08:00","description":"变量，是所有编程语言里都有的语法概念。在C/C++中，变量用于标示一个内存地址，而变 量名则在语法层面上代表这个地址。当链接器最终链接我们的程序时，就将这些名字替换 为实际的地址。在其他语言中，变量虽然或多或少有其他不同的含义，但也大致如此。","headline":"Lisp一瞥：增强型变量Symbol","mainEntityOfPage":{"@type":"WebPage","@id":"https://kevinlynx.cc/posts/lisp-symbol/"},"url":"https://kevinlynx.cc/posts/lisp-symbol/"}</script><title>Lisp一瞥：增强型变量Symbol | Loop in Codes</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Loop in Codes"><meta name="application-name" content="Loop in Codes"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="https://avatars.githubusercontent.com/u/789143?s=400&v=4" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Loop in Codes</a></div><div class="site-subtitle font-italic">Kevin Lynx's BLOG</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/kevinlynx" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/kevinlynx" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['kevinlynx','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>Lisp一瞥：增强型变量Symbol</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Lisp一瞥：增强型变量Symbol</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1300636800" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2011-03-21 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href="https://github.com/kevinlynx">Kevin Lynx</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3577 字"> <em>19 分钟</em>阅读</span></div></div></div><div class="post-content"><p>变量，是所有编程语言里都有的语法概念。在C/C++中，变量用于标示一个内存地址，而变 量名则在语法层面上代表这个地址。当链接器最终链接我们的程序时，就将这些名字替换 为实际的地址。在其他语言中，变量虽然或多或少有其他不同的含义，但也大致如此。</p><p>Lisp中的变量也差不多这样，但若将variable和Lisp中的 <strong>symbol</strong> 放在一起，则多少会 带来些困惑。</p><h2 id="lisp中的变量"><span class="mr-2">Lisp中的“变量”</span><a href="#lisp中的变量" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>很多教授Lisp的书中，大概会简单地告诉我们可以使用如下的方式定义一个全局变量 [1]_.</p><figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">defparameter</span> <span class="vg">*var*</span> <span class="mi">1</span><span class="p">)</span></code></pre></figure><p>如上代码，我们便定义了一个全局变量 <code class="language-plaintext highlighter-rouge">*var*</code> [2]_ ，它被初始化为数值1。同样，我们 还可以使用另一种基本相同的方式:</p><figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">defvar</span> <span class="vg">*var*</span> <span class="mi">1</span><span class="p">)</span></code></pre></figure><p>除了全局变量，我们还可以定义局部变量。但局部变量的定义稍显麻烦（却可能是另一种 设计考虑）。定义局部变量需要使用一些宏，或者特殊运算符，例如:</p><figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">var</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">"~a"</span> <span class="nv">var</span><span class="p">))</span></code></pre></figure><p>好了，就这些了。Lisp中关于变量的细节，也就这些。你甚至能用你在C/C++中的经验来窥 探一切。但是，我们很快就看到了很多困惑的地方。</p><p>我遇到的第一个困惑的地方来源于函数，那么等我讲讲函数再来分享下坎坷。</p><h2 id="lisp中的函数"><span class="mr-2">Lisp中的函数</span><a href="#lisp中的函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Lisp中的函数绝对不复杂，你绝对不用担心我在忽悠你 [3]_ 。作为一门函数式语言，其首要 任务就是加强函数这个东西在整个语言里的功能。如果你喜欢广阅各种与你工作不相干的 技术，你肯定已经对很多函数式语言世界中的概念略有耳闻。例如闭包，以及first class type [4]_ 。</p><p>Lisp中的函数就是first class type。这什么意思呢？直白来说， <strong>Lisp中的函数和变量 没什么区别，享有同等待遇</strong> 。进一步来说，变量fn的值可以是数值1，也可以是字符串 “hello”，甚至是某个函数。这其实就是C++程序员说的functor。</p><p>Lisp中定义函数非常简单:</p><figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">add2</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> 
  <span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="nv">x</span><span class="p">))</span></code></pre></figure><p>这样，我们就定义了一个名为add2，有1个参数，1个返回值的函数。要调用该函数时，只需 要 <code class="language-plaintext highlighter-rouge">(add2 2)</code> 即可。这简直和我们在Lisp中完成一个加法一模一样:<code class="language-plaintext highlighter-rouge">(+ 2 3)</code></p><p>Lisp作为一门函数式语言，其函数也能作为另一个函数的参数和返回值 [5]_</p><figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">apply-fn</span> <span class="p">(</span><span class="nv">fn</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">funcall</span> <span class="nv">fn</span> <span class="nv">x</span><span class="p">))</span></code></pre></figure><p>apply-fn函数第一个参数是一个函数，它使用funcall函数间接地调用fn指向的函数。作为 一个C++程序员，这简直太好理解了，这完全就是一个函数指针的语法糖嘛。于是，假设我 们要使用apply-fn来间接调用add2函数:</p><figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">apply-fn</span> <span class="nv">add2</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">;; wrong </span></code></pre></figure><p>可是这是不对的。我们需要通过另一个特殊操作符来完成这件事:</p><figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">apply-fn</span> <span class="nf">#'</span><span class="nv">add2</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">;; right</span></code></pre></figure><p>#‘操作符用于将add2对应的函数取出来，这么说当然不大准确。Again，作为一个C++程序员 ，这简直就是个取地址操作符&amp;的语法糖嘛。好吧，这么理解起来似乎没问题了。</p><p>Lisp中能甚至能在任何地方定义一个函数，例如我们创建一个函数，该函数返回创建出来的 函数，这是一个典型的讲解什么是 <strong>闭包</strong> 的例子:</p><figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">get-add-n</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="nf">#'</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">n</span><span class="p">)))</span></code></pre></figure><p>无论如何，get-add-n函数返回一个函数，该函数是add2函数的泛型实现。它可以将你传入 的参数加上n。这些代码里使用了lambda表达式。lambda表达式直白来说，就是创建一个字 面上的函数。这又是什么意思呢？就像我们在代码中写出2，写出”hello”一样，2就是个字 面上的数字，”hello”就是个字面上的字符串 [6]_ 。</p><p>那么，总而言之，通过lambda创建一个函数体，然后通过#‘操作符即可得到一个函数，虽然 没有名字。有了以上知识后，Again and again，作为一个C++程序员，很快我们就能得到一 个程序：定义变量，用变量去保存一个函数，然后通过这个变量来调用这个函数。这是多么 天经地义的事，就像之前那个通过参数调用其指向的函数一样:</p><figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="c1">;; wrong </span>
<span class="p">(</span><span class="nb">defvar</span> <span class="nv">fn</span> <span class="nf">#'</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)))</span>
<span class="p">(</span><span class="nv">fn</span> <span class="mi">3</span><span class="p">)</span></code></pre></figure><p>这样的代码是不对的，错误发生于第二行，无论你使用的Lisp实现是哪种，大概会得到如下 的错误信息:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>"The function FN is undefined."
</pre></table></code></div></div><p>老实说，这已经算是多么有迹可循的错误提示了啊。将以上代码和之前的apply-fn对比，是 多么得神似啊，可惜就是错的。这是我们遇到的第一个理解偏差导致的问题。如果你还不深 入探究，你将会在这一块遇到更多麻烦。及时地拿出你的勇气，披荆斩棘，刨根究底，绝对 是学习编程的好品质。</p><h2 id="万恶之源symbol"><span class="mr-2">“万恶之源“：SYMBOL</span><a href="#万恶之源symbol" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>上文中提到的变量函数之类，之所以会在某些时候与我们的理解发生偏差，并且总是存在些 神秘的地方无法解释。这完全是因为我们理解得太片面导致。Lisp中的Symbol可以说就是某 个变量，或者某个函数，但这太片面。Lisp中的Symbol拥有更丰富的含义。</p><h3 id="symbol的名字"><span class="mr-2">Symbol的名字</span><a href="#symbol的名字" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>就像很多语言的变量、函数名一样，Lisp中的Symbol比其他语言在命名方面更自由： <strong>只 要位于’|’字符之间的字符串，就表示一个合法的Symbol名。</strong> 我们可以使用函数 symbol-name来获取一个Symbol的名字，例如:</p><figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">symbol-name</span> <span class="ss">'|this is a symbol name|</span><span class="p">)</span></code></pre></figure><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>输出："this is a symbol name"
</pre></table></code></div></div><p>‘(quote)操作符告诉Lisp不要对其修饰的东西进行求值(evaluate)。但假如没有这个操作符 会怎样呢？后面我们将看到会怎样。</p><h3 id="symbol本质"><span class="mr-2">Symbol本质</span><a href="#symbol本质" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>&lt;ANSI Common Lisp&gt;一书中有句话真正地揭示了Symbol的本质： <strong>Symbols are real objects</strong> 。是的，Symbols是对象，这个对象就像我们理解的C++中的对象一样，它是一个 复合的数据结构。该数据结构里包含若干域，或者通俗而言：数据成员。借用&lt;ANSI Common Lisp&gt;中的一图：</p><blockquote><p><img data-src="/assets/res/lisp_symbol/symbol-obj.png" alt="image" data-proofer-ignore></p></blockquote><p>通过这幅图，可以揭开所有谜底。一个Symbol包含至少图中的几个域，例如Name、Value、 Function等。在Lisp中有很多函数来访问这些域，例如上文中使用到的symbol-name，这个 函数本质上就是取出一个Symbol的Name域。</p><h3 id="symbol与variable和function的联系"><span class="mr-2">Symbol与Variable和Function的联系</span><a href="#symbol与variable和function的联系" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>自然而然地，翻阅Lisp文档，我们会发现果然还有其他函数来访问Symbol的其他域，例如:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>symbol-function
symbol-value
symbol-package
symbol-plist
</pre></table></code></div></div><p>但是这些又与上文提到的变量和函数有什么联系呢？真相只有一个， <strong>变量、函数粗略来 说就是Symbol的一个域，一个成员。变量对应Value域，函数对应Function域。一个Symbol 这些域有数据了，我们说它们发生了绑定(bind)。</strong> 而恰好，我们有几个函数可以用于判 定这些域是否被绑定了值:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>boundp ;判定Value域是否被绑定
fboundp;判定Function域是否被绑定
</pre></table></code></div></div><p>通过一些代码来回味以上结论:</p><figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">defvar</span> <span class="vg">*var*</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="nb">boundp</span> <span class="ss">'*var*</span><span class="p">)</span> <span class="c1">; 返回真</span>
<span class="p">(</span><span class="nb">fboundp</span> <span class="ss">'*var*</span><span class="p">)</span> <span class="c1">; 返回假</span>
<span class="p">(</span><span class="nb">defun</span> <span class="vg">*var*</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span> <span class="c1">; 定义一个名为*var*的函数，返回值即为参数</span>
<span class="p">(</span><span class="nb">fboundp</span> <span class="ss">'*var*</span><span class="p">)</span> <span class="c1">; 返回真</span></code></pre></figure><p>上面的代码简直揭秘了若干惊天地泣鬼神的真相。首先，我们使用我们熟知的defvar定义了 一个名为 <code class="language-plaintext highlighter-rouge">*var*</code> 的变量，初值为1，然后使用boundp去判定 <code class="language-plaintext highlighter-rouge">*var*</code> 的Value域是否 发生了绑定。这其实是说： <strong>原来定义变量就是定义了一个Symbol，给变量赋值，原来就 是给Symbol的Value域赋值！</strong></p><p><strong>其实，Lisp中所有这些符号，都是Symbol。</strong> 什么变量，什么函数，都是浮云。上面的 例子中，紧接着用fboundp判断Symbol <code class="language-plaintext highlighter-rouge">*var*</code> 的Function域是否绑定，这个时候为假。 然后我们定义了一个名为 <code class="language-plaintext highlighter-rouge">*var*</code> 的函数，之后再判断，则已然为真。这也是为什么， <strong>在Lisp中某个函数可以和某个变量同名的原因所在。</strong> 从这段代码中我们也可以看出 defvar/defun这些操作符、宏所做事情的本质。</p><h3 id="more-more-more"><span class="mr-2">More More More</span><a href="#more-more-more" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>事情就这样结束了？Of course not。还有很多上文提到的疑惑没有解决。首先，Symbol是 如此复杂，那么Lisp如何决定它在不同环境下的含义呢？Symbol虽然是个对象，但它并不像 C++中的对象一样，它出现时并不指代自己！不同应用环境下，它指代的东西也不一样。这 些指代主要包括变量和函数，意思是说： <strong>Symbol出现时，要么指的是它的Value，要么是 它的Function。</strong> 这种背地里干的事情，也算是造成迷惑的一个原因。</p><p>当一个Symbol出现在一个List的第一个元素时，它被处理为函数。这么说有点迷惑人，因为 它带进了Lisp中代码和数据之间的模糊边界特性。简单来说，就是当Symbol出现在一个括号 表达式(s-expression)中第一个位置时，算是个函数，例如:</p><figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">add2</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; add2位于第一个位置，被当作函数处理</span>
<span class="p">(</span><span class="vg">*var*</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; 这里*var*被当作函数调用，返回3</span></code></pre></figure><p>除此之外，我能想到的其他大部分情况，一个Symbol都被指代为它的Value域，也就是被当 作变量，例如:</p><figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="vg">*var*</span> <span class="vg">*var*</span><span class="p">)</span> <span class="c1">; 这是正确的语句，返回1</span></code></pre></figure><p>这看起来是多么古怪的代码。但是运用我们上面说的结论，便可轻易解释：表达式中第一个 <code class="language-plaintext highlighter-rouge">*var*</code> 被当作函数处理，它需要一个参数；表达式第二部分的 <code class="language-plaintext highlighter-rouge">*var*</code> 被当作变量 处理，它的值为1，然后将其作为参数传入。</p><p>再来说说’(quote)操作符，这个操作符用于防止其操作数被求值。而当一个Symbol出现时， 它总是会被求值，所以，我们可以分析以下代码:</p><figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">symbol-value</span> <span class="vg">*var*</span><span class="p">)</span> <span class="c1">; wrong</span></code></pre></figure><p>这个代码并不正确，因为 <code class="language-plaintext highlighter-rouge">*var*</code> 总是会被求值，就像 <code class="language-plaintext highlighter-rouge">(*var* *var*)</code> 一样，第二 个 <code class="language-plaintext highlighter-rouge">*var*</code> 被求值，得到数字1。这里也会发生这种事情，那么最终就等同于:</p><figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">symbol-value</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">; wrong</span></code></pre></figure><p>我们试图去取数字1的Value域，而数字1并不是一个Symbol。所以，我们需要quote运算符:</p><figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">symbol-value</span> <span class="ss">'*var*</span><span class="p">)</span> <span class="c1">; right</span></code></pre></figure><p>这句代码是说，取Symbol <code class="language-plaintext highlighter-rouge">*var*</code> 本身的Value域！而不是其他什么地方。至此，我们 便可以分析以下复杂情况:</p><figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">defvar</span> <span class="vg">*name*</span> <span class="s">"kevin lynx"</span><span class="p">)</span>
<span class="p">(</span><span class="nb">defvar</span> <span class="vg">*ref*</span> <span class="ss">'*name*</span><span class="p">)</span> <span class="c1">; *ref*的Value保存的是另一个Symbol</span>
<span class="p">(</span><span class="nb">symbol-value</span> <span class="vg">*ref*</span><span class="p">)</span> <span class="c1">; 取*ref*的Value，得到*name*，再取*name*的Value</span></code></pre></figure><p>现在，我们甚至能解释上文留下的一个问题:</p><figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="c1">;; wrong </span>
<span class="p">(</span><span class="nb">defvar</span> <span class="nv">fn</span> <span class="nf">#'</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)))</span>
<span class="p">(</span><span class="nv">fn</span> <span class="mi">3</span><span class="p">)</span></code></pre></figure><p>给fn的Value赋值一个函数， <code class="language-plaintext highlighter-rouge">(fn 3)</code> 当一个Symbol作为函数使用时，也就是取其 Function域来做调用。但其Function域什么也没有，我们试图将一个Symbol的Value域当作 Function来使用。如何解决这个问题？想想，symbol-function可以取到一个Symbol的 Function域:</p><figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">symbol-function</span> <span class="ss">'fn</span><span class="p">)</span> <span class="nf">#'</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)))</span>
<span class="p">(</span><span class="nv">fn</span> <span class="mi">3</span><span class="p">)</span></code></pre></figure><p>通过显示地给fn的Function域赋值，而不是通过defvar隐式地对其Value域赋值，就可以使 <code class="language-plaintext highlighter-rouge">(fn 3)</code> 调用正确。还有另一个问题也能轻易解释:</p><figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">apply-fn</span> <span class="nv">add2</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">; wrong</span></code></pre></figure><p>本意是想传入add2这个Symbol的function域，但是直接这样写的话，传入的其实是add2的 Value域 [7]_ ，这当然是不正确的。对比正确的写法，我们甚至能猜测#‘运算符就是一个 取Symbol的Function域的运算符。进一步，我们还可以给出另一种写法:</p><figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">apply-fn</span> <span class="p">(</span><span class="nb">symbol-function</span> <span class="ss">'add2</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span></code></pre></figure><p>深入理解事情的背后，你会发现你能写出多么灵活的代码。</p><h2 id="end"><span class="mr-2">END</span><a href="#end" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>关于Symbol的内容还有更多，例如Package。正确理解这些内容以及他们之间的关系，有助 于更深刻地理解Lisp。</p><h2 id="注解"><span class="mr-2">注解</span><a href="#注解" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>[1] 在Lisp中全局变量又被称为dynamic variables<li>[2] Lisp中按照习惯通常在为全局变量命名时会加上星号，就像我们习惯使用g_一样<li>[3] 因为我确实在忽悠你<li>[4] first class type，有人翻译为“一等公民”，我觉得压力巨大<li>[5] 即高阶函数<li>[6] “字面“主要是针对这些信息会被词法分析程序直接处理<li>[7] 这可能导致更多的错误</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/lisp/'>lisp</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/lisp/" class="post-tag no-text-decoration" >lisp</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Lisp%E4%B8%80%E7%9E%A5%EF%BC%9A%E5%A2%9E%E5%BC%BA%E5%9E%8B%E5%8F%98%E9%87%8FSymbol+-+Loop+in+Codes&url=https%3A%2F%2Fkevinlynx.cc%2Fposts%2Flisp-symbol%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Lisp%E4%B8%80%E7%9E%A5%EF%BC%9A%E5%A2%9E%E5%BC%BA%E5%9E%8B%E5%8F%98%E9%87%8FSymbol+-+Loop+in+Codes&u=https%3A%2F%2Fkevinlynx.cc%2Fposts%2Flisp-symbol%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fkevinlynx.cc%2Fposts%2Flisp-symbol%2F&text=Lisp%E4%B8%80%E7%9E%A5%EF%BC%9A%E5%A2%9E%E5%BC%BA%E5%9E%8B%E5%8F%98%E9%87%8FSymbol+-+Loop+in+Codes" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/tips/">tips</a> <a class="post-tag" href="/tags/c-c/">c/c++</a> <a class="post-tag" href="/tags/erlang/">erlang</a> <a class="post-tag" href="/tags/dht/">dht</a> <a class="post-tag" href="/tags/lisp/">lisp</a> <a class="post-tag" href="/tags/lua/">lua</a> <a class="post-tag" href="/tags/p2p/">p2p</a> <a class="post-tag" href="/tags/magnet/">magnet</a> <a class="post-tag" href="/tags/octopress/">octopress</a> <a class="post-tag" href="/tags/ruby/">ruby</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/lisp-writer/"><div class="card-body"> <em class="small" data-ts="1299945600" data-df="YYYY-MM-DD" > 2011-03-13 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>用lisp开发博客客户端</h3><div class="text-muted small"><p> 最近一直在学习Lisp这门语言。回头一看，基本上接近1个月了。刚开始接触Lisp是因为看 了&amp;lt;Lisp本质&amp;gt;，然后我发现有很多人宗教般地忠诚这门语言，于是就来了兴趣。 当然并不是每次因为某篇写得很geek技术文章就去学习某个新的技术点。一个月时间对我来 说还是很珍贵了。但是Lisp绝对是大部分程序员都值得一学的语言（就像Haskell一样）。 我能给出的简单理由包括： ...</p></div></div></a></div><div class="card"> <a href="/posts/lisp-rss/"><div class="card-body"> <em class="small" data-ts="1301414400" data-df="YYYY-MM-DD" > 2011-03-30 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Lisp实践：开发RSS阅读器</h3><div class="text-muted small"><p> 一、RSS阅读器的实现 RSS Reader的实现并不像它看上去那么复杂。当初在决定写这个作为Lisp练习时，甚至觉得 没有多少内容可做。其简单程度甚至用不了你启动一个慢速IDE的时间:D。对Lisp无兴趣的 TX只需要读完这一节即可， 什么是RSS阅读器? RSS在实现上，可以说是XML的又一次扩张式的应用。因为RSS最重要的东西就是一个XML文件 。RSS主要用于Web中的内容同...</p></div></div></a></div><div class="card"> <a href="/posts/build-blog-by-lisp/"><div class="card-body"> <em class="small" data-ts="1317225600" data-df="YYYY-MM-DD" > 2011-09-29 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>使用Lisp搭建独立博客</h3><div class="text-muted small"><p> 本文描述如何使用Lisp工具集搭建一个完整的个人博客站点。一个搭建好的例子站点可以参看我的个人博客：http://codemacro.com。 要搭建一个独立博客，需要两方面的支持。一是博客软件，二是根据选择的博客软件取得必须的“硬件“。例如我这里使用的是Lisp工具集，就需要一个可以完全控制的服务器，所以这里我需要一个VPS。当然，购买一个合适的域名也是必须的。以下将针对这些内容做描述。...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/lisp-writer/" class="btn btn-outline-primary" prompt="上一篇"><p>用lisp开发博客客户端</p></a> <a href="/posts/lisp-rss/" class="btn btn-outline-primary" prompt="下一篇"><p>Lisp实践：开发RSS阅读器</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "kevinlynx/kevinlynx.github.io", "data-repo-id": "R_kgDOIAJnIQ", "data-category": "General", "data-category-id": "DIC_kwDOIAJnIc4CReqT", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "top", "data-lang": "zh-CN", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/kevinlynx">Kevin Lynx</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/tips/">tips</a> <a class="post-tag" href="/tags/c-c/">c/c++</a> <a class="post-tag" href="/tags/erlang/">erlang</a> <a class="post-tag" href="/tags/dht/">dht</a> <a class="post-tag" href="/tags/lisp/">lisp</a> <a class="post-tag" href="/tags/lua/">lua</a> <a class="post-tag" href="/tags/p2p/">p2p</a> <a class="post-tag" href="/tags/magnet/">magnet</a> <a class="post-tag" href="/tags/octopress/">octopress</a> <a class="post-tag" href="/tags/ruby/">ruby</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">发现新版本的内容。</p><button type="button" class="btn btn-primary" aria-label="Update"> 更新 </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
