<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: lua | loop in codes]]></title>
  <link href="http://codemacro.com/categories/lua/atom.xml" rel="self"/>
  <link href="http://codemacro.com/"/>
  <updated>2013-02-12T21:33:16+08:00</updated>
  <id>http://codemacro.com/</id>
  <author>
    <name><![CDATA[Kevin Lynx]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Lua中动态产生函数]]></title>
    <link href="http://codemacro.com/2012/08/13/dynamic-method-in-lua/"/>
    <updated>2012-08-13T15:56:00+08:00</updated>
    <id>http://codemacro.com/2012/08/13/dynamic-method-in-lua</id>
    <content type="html"><![CDATA[<p>可以结合<a href="http://codemacro.com/2012/08/02/simple-oo-in-lua/">Lua里实现简单的类-对象</a>看。在我的应用中，存在类似以下代码：</p>

<p>{% highlight lua %}
function Item.new()</p>

<pre><code>local o = {
    property = {}
}
return newObject(o, Item)
</code></pre>

<p>end
{% endhighlight %}</p>

<p><code>property</code>是一个key-value的表，里面的内容不是固定的。最开始我为Item类写了get/set函数，用于存取property表里的值。但这样写起来还是有点麻烦。Ruby里可以动态产生类成员函数，其实Lua里也可以。其思路就是通过metatable来做：</p>

<!-- more -->


<p>{% highlight lua %}
-- 为newObject增加一个可选参数，该参数是一个函数，当在表示类的table里无法找到成员时就调用该可选参数
function newObject(o, class, after)</p>

<pre><code>class.__index = function (self, key) return class[key] or after(self, key) end
return setmetatable(o, class)
</code></pre>

<p>end
{% endhighlight %}</p>

<p>然后就是编写这个after函数，我的理想方式是，例如property里有Name和Index的key-value，那么就可以通过这样的方式来存取：</p>

<p>{% highlight lua %}
item = Item.new()
print(item:Name())
item:SetName("hello")
print(item:Index()
item:SetIndex(101)
{% endhighlight %}</p>

<p>after函数的实现：</p>

<p>{% highlight lua %}
function Item.new()</p>

<pre><code>local o = {
    property = {}
}
local function after(self, key)
    local name = string.match(key, "Set(%a+)")
    if name then 
        return function (self, value)
            self:set(name, value)
        end
    else
        return function (self)
            return self.property[key] and self.property[key].value
        end
    end
end
return newObject(o, Item, after)
</code></pre>

<p>end
{% endhighlight %}</p>

<p>执行过程就为：</p>

<ul>
<li>当item:Name()执行时，首先试图获取Item上的Name成员，没找到就调用传入的after函数，这个函数检查<code>Name</code>这个字符串是否是<code>SetXX</code>的形式，如果不是则返回一个获取函数；这个时候取得Name成员，然后将其作为函数调用，相当于调用了after刚才返回的函数</li>
<li>item:SetName("hello")过程类似，只不过调用了另一个返回函数。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让wxListCtrl支持子item编辑]]></title>
    <link href="http://codemacro.com/2012/08/07/edit-item-wxlistctrl/"/>
    <updated>2012-08-07T13:48:00+08:00</updated>
    <id>http://codemacro.com/2012/08/07/edit-item-wxlistctrl</id>
    <content type="html"><![CDATA[<p>我使用的wxLua版本信息为<code>wxLua 2.8.7.0 built with wxWidgets 2.8.8</code>，也就是LuaForWindows_v5.1.4-40.exe这个安装包里自带的wxLua。我不知道其他wxWidgets版本里wxListCtrl怎样，但我使用的版本里wxListCtrl是不支持编辑里面的子item的。在我使用的report模式下，子item也就是特定某一行一列的item。</p>

<p>google了一下，发现悲剧地需要自己实现，主要就是自己显示一个wxTextCtrl：</p>

<!-- more -->


<h2>{% highlight lua %}</h2>

<p>-- file: wxListCtrlTextEdit.lua
-- author: Kevin Lynx</p>

<h2>-- date: 08.06.2012</h2>

<p>local EditList = {}</p>

<p>-- get the column by an abs point
function EditList:getColumn(x)</p>

<pre><code>local cols = self.listctrl:GetColumnCount()
local cx = 0
for i = 0, cols - 1 do
    local w = self.listctrl:GetColumnWidth(i)
    if x &lt;= cx + w then return i end
    cx = cx + w
end
return -1
</code></pre>

<p>end</p>

<p>-- when a mouse down, show a text edit control
function EditList:onLeftDown(evt)</p>

<pre><code>if self.editor:IsShown() then
    self:closeEditor()
end
local p = evt:GetPoint()
local row = evt:GetIndex()
local col = self:getColumn(p.x)
local rect = wx.wxListCtrlEx.GetSubItemRect(self.listctrl, row, col)
rect:SetHeight(rect:GetHeight() + 5) -- adjust
self.editor:SetSize(rect)
self.editor:Show()
self.editor:SetValue(wx.wxListCtrlEx.GetItemText(self.listctrl, row, col))
self.editor:SetFocus()
self.col = col
self.row = row
</code></pre>

<p>end</p>

<p>function EditList:closeEditor()</p>

<pre><code>if not self.editor:IsShown() then return end
self.editor:Hide()
self.listctrl:SetItem(self.row, self.col, self.editor:GetValue())
</code></pre>

<p>end</p>

<p>function EditList:initialize()</p>

<pre><code>self.editor = wx.wxTextCtrl(self.listctrl, wx.wxID_ANY, "", wx.wxDefaultPosition, wx.wxDefaultSize, wx.wxTE_PROCESS_ENTER + wx.wxTE_RICH2)
self.editor:Connect(wx.wxEVT_COMMAND_TEXT_ENTER, function () self:closeEditor() end)
-- not work actually
self.editor:Connect(wx.wxEVT_COMMAND_KILL_FOCUS, function () self:closeEditor() end)
self.editor:Hide()
</code></pre>

<p>end</p>

<p>function wx.wxListCtrlTextEdit(listctrl)</p>

<pre><code>local o = {
    listctrl = listctrl,
    editor = nil,
}
local editlist = newObject(o, EditList)
editlist:initialize()
listctrl:Connect(wx.wxEVT_COMMAND_LIST_ITEM_RIGHT_CLICK, function (evt) editlist:onLeftDown(evt) end)
listctrl:Connect(wx.wxEVT_COMMAND_LIST_ITEM_FOCUSED, function () editlist:closeEditor() end)
return listctrl
</code></pre>

<p>end</p>

<p>{% endhighlight %}</p>

<p>其原理就是获取到当前鼠标点击所在的子item位置，然后在此位置显示一个wxEditCtrl即可。以上代码需要依赖我之前写的<a href="http://codemacro.com/2012/08/02/simple-oo-in-lua/">Lua里实现简单的类-对象</a>中的代码，同时依赖以下针对wxListCtrl的扩展接口：</p>

<h2>{% highlight lua %}</h2>

<p>-- file: wxListCtrlExtend.lua
-- author: Kevin Lynx
-- date: 08.07.2012</p>

<h2>-- brief: extend some util functions to wx.wxListCtrl</h2>

<p>wx.wxListCtrlEx = {}</p>

<p>function wx.wxListCtrlEx.GetSubItemRect(listctrl, item, col)</p>

<pre><code>local rect = wx.wxRect()
listctrl:GetItemRect(item, rect)
local x = 0
local w = 0
for i = 0, col do
    w = listctrl:GetColumnWidth(i)
    x = x + w
end
return wx.wxRect(x - w, rect:GetY(), w, rect:GetHeight())
</code></pre>

<p>end</p>

<p>function wx.wxListCtrlEx.GetItemText(listctrl, item, col)</p>

<pre><code>local info = wx.wxListItem()
info:SetId(item)
info:SetColumn(col)
info:SetMask(wx.wxLIST_MASK_TEXT)
listctrl:GetItem(info)
return info:GetText()
</code></pre>

<p>end</p>

<p>{% endhighlight %}</p>

<p>在我看到的wxWidgets官方文档里，其实wxListCtrl已经有<code>GetSubItemRect</code>接口，并且在另一些示例代码里，也看到了<code>GetItemText</code>接口，但是，我使用的版本里没有，所以只好自己写。基于以上，要使用这个可以支持编辑子item的wxListCtrl，可以：</p>

<p>{% highlight lua %}
list = wx.wxListCtrlTextEdit(wx.wxListCtrl(dialog, wx.wxID_ANY, wx.wxDefaultPosition, wx.wxDefaultSize, wx.wxLC_REPORT))
{% endhighlight %}</p>

<p>也就是通过wx.wxListCtrlTextEdit这个函数做下处理，这个函数返回的是本身的wxListCtrl。当然更好的方式是使用继承之类的方式，开发一种新的控件，但在Lua中，针对usedata类型的扩展貌似只能这样了。</p>

<p>最好吐槽下，这个控件扩展其实很恶心。本来我打算当编辑控件失去焦点后就隐藏它，但是往编辑控件上注册KILL_FOCUS事件始终不起作用；我又打算弄个ESC键盘事件去手动取消，但显然wxTextCtrl是不支持键盘事件的。好吧，凑合用了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lua里实现简单的类-对象]]></title>
    <link href="http://codemacro.com/2012/08/02/simple-oo-in-lua/"/>
    <updated>2012-08-02T10:18:00+08:00</updated>
    <id>http://codemacro.com/2012/08/02/simple-oo-in-lua</id>
    <content type="html"><![CDATA[<p>要在Lua里实现面向对象有很多方法，为了支持面向对象的一些特性（类、对象、继承、重载等），其实现可能会比较复杂。看看云风的<a href="http://blog.codingnow.com/2006/06/oo_lua.html">这篇</a>，以及后面的评论，有总结的不错的。这真是让人对Lua刮目相看。但是我并不需要这些机制，一般情况下我只需要支持类即可。</p>

<p>类其实就是定义一个对象的函数模板，避免我写出带模块名并且第一个参数是操作对象的函数（像C一样）。以下代码提炼于rapanui（基于<a href="http://getmoai.com/">moai</a>的高层封装），摘抄于几个月前我基于rapanui移植到android上的一个<a href="https://github.com/kevinlynx/crazyeggs_mobile">小游戏</a>：</p>

<!-- more -->


<p>{% highlight lua %}
local function newindex(self, key, value)</p>

<pre><code>getmetatable(self).__object[key] = value
</code></pre>

<p>end</p>

<p>local function index(self, key)</p>

<pre><code>return getmetatable(self).__object[key]
</code></pre>

<p>end</p>

<p>function newObject(o, class)</p>

<pre><code>class.__index = class
setmetatable(o, class)
return setmetatable({}, { __newindex = newindex, __index = index, __object = o })
</code></pre>

<p>end
{% endhighlight %}</p>

<p>基于newObject函数，可以这样定义类：</p>

<p>{% highlight lua %}
Button = {}</p>

<p>function Button.new(text, x, y, onclick, parent)</p>

<pre><code>-- 定义这个类的数据成员
local obj = {
    text = text,
    onclick = onclick,
    normal_img = nil,
    text_inst = nil,
    hover_img = nil,
}
obj = newObject(obj, Button)
...
return obj
</code></pre>

<p>end</p>

<p>function Button:onTouchDown(x, y)</p>

<pre><code>...
-- 可以访问成员，即使看起来normal_img不属于Button这个table
self.normal_img.visible = true
</code></pre>

<p>end</p>

<p>function Button:onTouchUp(x, y)</p>

<pre><code>...
</code></pre>

<p>end
{% endhighlight %}</p>

<p>通过以上定义后，就可以以面向对象的方式来使用Button类了：</p>

<p>{% highlight lua %}
local btn = Button.new()
btn:OnTouchDown(100, 100)
btn:OnTouchUp(100, 100)
{% endhighlight %}</p>

<p>其实现原理，主要就是将类的函数集通过<code>__index</code>开放给对象，在这些函数中，其<code>self</code>就像c++ 中的<code>this</code>一样拥有多态性，即其是创建出来的对象，而不是作为类角色的那个<code>table</code>（例如Button）。</p>

<hr/>


<h4>8.13.2012更新</h4>

<p>其实根本没必要这么复杂，<code>newObject</code>函数多引入了一个空表，实在看不出有什么作用，修改后的版本简单直接：</p>

<p>{% highlight lua %}
function newObject(o, class)</p>

<pre><code>class.__index = class
return setmetatable(o, class)
</code></pre>

<p>end
{% endhighlight %}</p>

<p>因为只需要将类定义的函数引入到实际对象里，使用方法相同。另外上文中提到的一句话：</p>

<blockquote><p>在这些函数中，其<code>self</code>就像c++ 中的<code>this</code>一样拥有多态性，即其是创建出来的对象</p></blockquote>

<p>其实这是不对的，这个self应该就是触发这个metamethod的table，不具备什么<code>多态性</code>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tolua的tolua_toxxx系列API设计]]></title>
    <link href="http://codemacro.com/2012/05/10/tolua-api/"/>
    <updated>2012-05-10T00:00:00+08:00</updated>
    <id>http://codemacro.com/2012/05/10/tolua-api</id>
    <content type="html"><![CDATA[<p>我们使用tolua++手工绑定c/c++接口到lua中，在绑定的接口实现里，就需要取出传入的参数。tolua++中提供了一系列tolua_toxxx函数，例如：</p>

<p>{% highlight c %}
lua_Number tolua_tonumber(lua_State <em>L, int narg, lua_Number def)
const char </em>tolua_tostring(lua_State <em>L, int narg, const char </em>def)
{% endhighlight %}</p>

<p>这些函数都有一个def参数。乍一看，这些函数使用起来很简单。传入lua_State，传入参数在栈中的位置，然后再传一个<strong>失败</strong>后返回的默认值。</p>

<p>我重点要说的是这里这个<strong>失败</strong>，按正常程序员的理解，针对lua而言，什么情况下算失败呢？lua语言里函数参数支持不传，此时实参为nil，将nil转换为一个c类型必然失败；参数类型不正确算不算失败？你传一个user data，c里按数字来取，这也算失败。</p>

<!-- more -->


<p>这么简单的API还需要多纠结什么呢？然后我们浩浩荡荡地写了上百个接口，什么tolua_tostring/tolua_tonumber的使用少说也有500了吧？</p>

<p>然后有一天，服务器宕机了，空指针:</p>

<p>{% highlight c %}
/<em> 失败返回""，还能省空指针的判断 </em>/
const char <em>name = tolua_tostring(L, 1, "");
if (name[0] == '\0') { /</em> 空串总得判断吧 */</p>

<pre><code>...
</code></pre>

<p>}
{% endhighlight %}</p>

<p>跟踪后发现，脚本里传入的是nil，这里的name取出来是NULL，而不是""（的地址）。然后吐槽了一下这个API，辛苦地修改了所有类似代码，增加对空指针的判断。我没有多想。</p>

<p>故事继续，有一天服务器虽然没宕机，但功能不正常了:</p>

<p>{% highlight c %}
float angle = (float) tolua_tonumber(L, 1, 2 * PI);
...
{% endhighlight %}</p>

<p>这个意思是，这个函数的参数1默认是2*PI，什么是默认？lua里某函数参数不传，或传nil就是使用默认。因为不传的话，这个实参本身就是nil。但，tolua_tonumber的行为不是这样的，它的实现真是偷懒:</p>

<p>{% highlight c %}
TOLUA_API lua_Number tolua_tonumber (lua_State* L, int narg, lua_Number def)
{
 return lua_gettop(L)&lt;abs(narg) ? def : lua_tonumber(L,narg);
}</p>

<p>TOLUA_API const char<em> tolua_tostring (lua_State</em> L, int narg, const char* def)
{
 return lua_gettop(L)&lt;abs(narg) ? def : lua_tostring(L,narg);
}
{% endhighlight %}</p>

<p>意思是，只有当你不传的时候，它才返回默认值，否则就交给lua的API来管，而lua这些API是不支持应用层的默认参数的，对于lua_tonumber错误时就返回0，lua_tostring错误时就返回NULL。</p>

<p>这种其行为和其带来的common sense不一致的API设计，实在让人蛋疼。什么是common sense呢？就像一个UI库里的按钮，我们都知道有click事件，hover事件，UI库的文档甚至都不需要解释什么是click什么是hover，因为大家看到这个东西，就有了共识，无需废话，这就是common sense。就像tolua的这些API，非常普通，大家一看都期待在意外情况下你能返回def值。但它竟然不是。实在不行，你可以模仿lua的check系列函数的实现嘛:</p>

<p>{% highlight c %}
LUALIB_API lua_Number luaL_checknumber (lua_State <em>L, int narg) {
  lua_Number d = lua_tonumber(L, narg);
  if (d == 0 &amp;&amp; !lua_isnumber(L, narg))  /</em> avoid extra test when d is not 0 */</p>

<pre><code>tag_error(L, narg, LUA_TNUMBER);
</code></pre>

<p>  return d;
}
{% endhighlight %}</p>

<p>即，根本不用去检查栈问题，直接在lua_tonumber之后再做包装检查。何况，lua需要你去检查栈吗？当你访问了栈外的元素时，lua会自动返回一个全局常量luaO_nilobject:</p>

<p>{% highlight c %}
static TValue <em>index2adr(lua_State </em>L, int idx) {</p>

<pre><code>...
if (o &gt;= L-&gt;top) return cast(TValue*, luaO_nilobject);
</code></pre>

<p>}
{% endhighlight %}</p>

<p>另，程序悲剧也来源于臆想。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[传递Lua函数到C/C++中]]></title>
    <link href="http://codemacro.com/2011/05/09/lua-function-arg/"/>
    <updated>2011-05-09T00:00:00+08:00</updated>
    <id>http://codemacro.com/2011/05/09/lua-function-arg</id>
    <content type="html"><![CDATA[<h2>问题</h2>

<p>在Lua中，因为函数也是第一类值，所以会出现将函数作为另一个函数的参数，或者函数作
为函数的返回值。这种机制在很多地方都能代码更灵活更简洁，例如:</p>

<p>{% highlight lua %}</p>

<pre><code>table.sort(table [,comp])
</code></pre>

<p>{% endhighlight %}</p>

<p>这里的comp就要求传入一个函数，我们在调用时，大概会有如下形式:</p>

<p>{% highlight lua %}</p>

<pre><code>table.sort(t, comp) -- 直接写函数名
table.sort(t, local_comp) -- 某个局部函数
table.sort(t, function (a, b) xxx end ) -- 临时构造一个匿名函数
</code></pre>

<p>{% endhighlight %}</p>

<p>其中最后一种方式最为灵活，任意时候在需要的时候构造一个匿名函数。这种在Lua自身的
环境中使用，自然没有问题。但是，当我们在C/C++中注册一些函数到Lua环境中，而这些 函数也需要使用函数参数的时候，问题就出来了。</p>

<!-- more -->


<p>Lua本身是不支持将Lua函数作为函数参数传入C/C++的，不管这个想要传入的函数是全局的
、局部的、或者匿名的（匿名的本质上也算局部的）。一般情况下，我们唯一的交互方式，
不是传入一个函数，而是一个全局函数名。C/C++保存这个函数名，在需要回调Lua的时候，
就在Lua全局表中找到这个函数（根据函数名），然后再调用之。情况大致如下:</p>

<p>{% highlight lua %}</p>

<pre><code>function lua_func () xxx end
cfunc(lua_func) -- wrong
cfunc("lua_func") -- right
</code></pre>

<p>{% endhighlight %}</p>

<p>我们这回的脚本模块，策划会大量使用需要回调函数的C/C++函数。显然，创建大量的全局 函数，先是从写代码的角度看，就是很伤神的。</p>

<h2>解决</h2>

<p>我们最终需要的方式，大概如下:</p>

<p>{% highlight lua %}</p>

<pre><code>cfunc(lua_func) -- ok
cfunc(function () xxx end) -- ok
local xxx = function () xxx end
cfunc(xxx) -- ok
</code></pre>

<p>{% endhighlight %}</p>

<p>要解决这个问题，我的思路是直接在Lua层做一些包装。因为C/C++那边仅支持传入一个全局
函数名（当然不一定得全局的，根据实际情况，可能在其他自己构造的表里也行），也就是
一个字符串，所以我的思路就是将Lua函数和一个唯一的字符串做映射。:</p>

<p>{% highlight lua %}</p>

<pre><code>function wrap (fn)
    local id = generate_id()
    local fn_s = "__callback_fn"..id
    _G[fn_s] = fn
    return fn_s
end
</code></pre>

<p>{% endhighlight %}</p>

<p>这个wrap函数，就是将一个函数在全局表里映射到一个字符串上，那么在使用时:</p>

<p>{% highlight lua %}</p>

<pre><code>cfunc(wrap(function () xxx end))
cfunc(const char *fn_name, xxx); -- cfunc的原型
</code></pre>

<p>{% endhighlight %}</p>

<p>cfunc是C/C++方注册进Lua的函数，它的原型很中规中矩，即：只接收一个函数名，一个字
符串，如之前所说，C/C++要调用这个回调函数时，就根据这个字符串去查找对应的函数。
脚本方在调用时，如果想传入一个匿名函数了，就调用wrap函数包装一下即可。</p>

<h2>一个改进</h2>

<p>上面的方法有个很严重的问题，在多次调用wrap函数后，将导致全局表也随之膨胀。我们需
要想办法在C/C++完成回调后，来清除wrap建立的数据。这个工作当然可以放到C/C++来进行
，例如每次发生回调后，就设置下全局表。但这明显是不对的，因为违背了接口的设计原则
，这个额外的机制是在Lua里添加的，那么责任也最好由Lua来负。要解决这个问题，就可以
使用Lua的metamethods机制。这个机制可以在Lua内部发生特定事件时，让应用层得到通知。
这里，我们需要关注__call事件。</p>

<p>Lua中只要有__call metamethod的值，均可被当作函数调用。例如:</p>

<pre><code>ab(1, 2) 
</code></pre>

<p>这里这个函数调用形式，Lua就会去找ab是否有__call metamethod，如果有，则调用它。这
个事实暗示我们，一个table也可以被调用。一个改进的wrap函数如下:</p>

<p>{% highlight lua %}</p>

<pre><code>local function create_callback_table (fn, name)
    local t = {}
    t.callback = fn
    setmetatable (t, {__call =  -- 关注__call
        function (func, ...) -- 在t(xx)时，将调用到这个函数
            func.callback (...) -- 真正的回调
            del_callback (name) -- 回调完毕，清除wrap建立的数据
        end })
    return t
end

function wrap (fn)
    local id = generate_func_id() -- 产生唯一的id
    local fn_s = "_callback_fn"..id
    _G[fn_s] = create_callback_table(fn, fn_s) -- _G[fn_s]对应的是一个表
    return fn_s
end
</code></pre>

<p>{% endhighlight %}</p>

<p>在我们的C/C++程序中，依然如往常一样，先是从_G里取出函数名对应的对象。虽然这个对
象现在已经是一个table。然后lua_call。</p>

<p>上面的代码是否会在原有基础上增加不可接受的性能代价？虽然我没有做过实际测试，但是 从表明看来，排除meta
table在Lua里的代价，也就多了几次Lua函数调用。</p>

<p>最后，感叹一下，Lua里的table及metatable机制，实在非常强大。这种强大不是功能堆砌
出来的强大，而是简单东西组合出来的强大。其背后的设计思想，着实让人佩服。</p>

<p><strong>4.26.2011 Update</strong></p>

<p>之前的文中说“Lua本身是不支持将Lua函数作为函数参数传入C/C++的“，这句话严格来说不
正确（由某网友评论）。假设函数cfun由c/c++注册，我们是可以编写如下代码的:</p>

<pre><code>cfunc(print) -- 传入Lua函数
</code></pre>

<p>但是问题在于，我们无法取出这个函数并保存在c/c++方。Lua提供了一些接口用于取cfunc
的参数，例如luaL_checknumber（封装lua_tonumber）。但没有类似luaL_checkfunction的
接口。Lua中的table有同样的问题。究其原因，主要是Lua中的函数没有直接的c/c++数据结 构对应。</p>

<p>;; END</p>
]]></content>
  </entry>
  
</feed>
