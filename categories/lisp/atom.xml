<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: lisp | loop in codes]]></title>
  <link href="http://codemacro.com/categories/lisp/atom.xml" rel="self"/>
  <link href="http://codemacro.com/"/>
  <updated>2016-08-16T20:44:30+08:00</updated>
  <id>http://codemacro.com/</id>
  <author>
    <name><![CDATA[Kevin Lynx]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Lisp中定义变量*var*和var有什么不同？]]></title>
    <link href="http://codemacro.com/2012/08/14/dynamic-scope-in-lisp/"/>
    <updated>2012-08-14T15:53:00+08:00</updated>
    <id>http://codemacro.com/2012/08/14/dynamic-scope-in-lisp</id>
    <content type="html"><![CDATA[<p>参考<a href="http://stackoverflow.com/questions/11932876/whats-difference-between-var-and-var-when-using-defvar">What&rsquo;s difference between <em>var</em> and var when using defvar?</a></p>

<p>其实，Common Lisp中使用defvar定义变量加不加星号没有区别。这只是一种Lisp程序员的约定。Lisp中并不使用特定的符号来影响语法元素，例如Ruby中通过给变量添加@前缀来标示该变量为类成员变量。这个问题引出了lisp总dynamic scope这个话题。</p>

<!-- more -->


<p>Lisp中变量分为两种，分别为<code>lexical</code>和<code>special</code>。这两种不同的变量有不同的作用域(scope)：词法作用域(lexical scope)和动态作用域(dynamic scope)。<code>special variables</code>通过<code>defvar/defparameter/declare</code>来定义。而<code>lexical variables</code>通常在<code>let</code>中定义。</p>

<p>这两种作用域有什么不同呢？引用\<ANSI Common Lisp\>里说的：</p>

<blockquote><p>Under lexical scope, a symbol refers to the variable that has that name in the context where the symbol appears (define)</p>

<p>With dynamic scope, we look for a variable in the environment where the function is called, not in the environment where it was defined.</p></blockquote>

<p>所以：</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">defvar</span> <span class="nv">b</span> <span class="mi">3</span><span class="p">)</span><span class="nv">&lt;/p&gt;</span>

<span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">defun</span> <span class="nv">add-to-b</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">b</span><span class="p">))</span><span class="nv">&lt;/p&gt;</span>

<span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nv">add-to-b</span> <span class="mi">1</span><span class="p">)</span>
  <span class="nv">=&gt;</span> <span class="nv">4&lt;/p&gt;</span>

<span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">b</span> <span class="mi">4</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nv">add-to-b</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">b</span><span class="p">))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">4</span><span class="p">)</span><span class="nv">&lt;/p&gt;</span>

<span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">a</span> <span class="mi">3</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">defun</span> <span class="nv">add-to-a</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">a</span><span class="p">)))</span><span class="nv">&lt;/p&gt;</span>

<span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nv">add-to-a</span> <span class="mi">1</span><span class="p">)</span>
  <span class="nv">=&gt;</span> <span class="nv">4&lt;/p&gt;</span>

<span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">a</span> <span class="mi">4</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nv">add-to-a</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">a</span><span class="p">))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">4</span><span class="p">)</span></code></pre></div></p>

<p><code>add-to-b</code>这个函数中使用的变量<code>b</code>是<code>special variable</code>，所以在调用<code>add-to-b</code>时，取的就是调用(called)这个函数时环境中的变量，所以：</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">b</span> <span class="mi">4</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nv">add-to-b</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">b</span><span class="p">))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">4</span><span class="p">)</span></code></pre></div></p>

<p>取的就是let中临时出现的<code>b</code>。而<code>add-to-a</code>这个函数中使用的变量<code>a</code>是<code>lexical variable</code>，所以调用这个函数时，取的就是这个函数定义(defined)时的<code>a</code>，所以无论在哪里调用<code>add-to-a</code>，都是取的：</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">a</span> <span class="mi">3</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">defun</span> <span class="nv">add-to-a</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">a</span><span class="p">)))</span></code></pre></div></p>

<p>这里的<code>a</code>，也就是一直是3。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Lisp搭建独立博客]]></title>
    <link href="http://codemacro.com/2011/09/29/build-blog-by-lisp/"/>
    <updated>2011-09-29T00:00:00+08:00</updated>
    <id>http://codemacro.com/2011/09/29/build-blog-by-lisp</id>
    <content type="html"><![CDATA[<p>本文描述如何使用Lisp工具集搭建一个完整的个人博客站点。一个搭建好的例子站点可以参看我的个人博客：<a href="http://codemacro.com%E3%80%82">http://codemacro.com%E3%80%82</a></p>

<p>要搭建一个独立博客，需要两方面的支持。一是博客软件，二是根据选择的博客软件取得必须的“硬件“。例如我这里使用的是Lisp工具集，就需要一个可以完全控制的服务器，所以这里我需要一个VPS。当然，购买一个合适的域名也是必须的。以下将针对这些内容做描述。</p>

<!-- more -->


<h2>获取VPS及域名</h2>

<p>VPS提供商国内国外都有很多。我选择的是 <a href="http://www.rapidxen.net/">rapidxen</a>
，128M内存，1年70来美元，算是国外比较便宜的，速度上还过得去。</p>

<p>购买了VPS后，可以进入后台管理页面安装VPS操作系统。同样，因为我使用的是Lisp，我选择安装了Debian 6.0 squeeze
(minimal)64位。实际上我更倾向于32位，因为我的PC系统就是32位，方便测试。安装系统非常简单，基本随意设置下即可。值得注意的是，除了修改root密码外，最好修改下ssh端口，具体设置方法可以另行搜索。此外，因为后面我会使用nginx作为HTTP前端服务器，为了方便安装nginx，最好更新下软件源列表，编辑etc/apt/source.list:</p>

<pre><code>deb http://ftp.us.debian.org/debian squeeze main
deb http://packages.dotdeb.org stable all
deb-src http://packages.dotdeb.org stable all
deb http://php53.dotdeb.org stable all
deb-src http://php53.dotdeb.org stable all
</code></pre>

<p>购买VPS最主要的，就是获取到一个独立IP，如图：</p>

<p><img src="/assets/res/build_blog/vps.png" alt="image" /></p>

<p>然后可以去购买域名。同样，也有很多域名服务商。这里我选择的是 <a href="http://www.godaddy.com/">godaddy</a>
，我选择的域名codemacro.com一年11美元。购买了域名后，就需要将域名和VPS
IP关联起来。详细设置也可以另行搜索。这里简要提下：在成功登入godaddy后，选择My Account，进入自己的域名，选择DNS
Manager，然后添加域名映射即可，如图：</p>

<p><img src="/assets/res/build_blog/domain.png" alt="image" /></p>

<p>通过以上设置后，你购买的域名就成功指向你购买的VPS地址了。可以通过ping来观察是否指向成功。</p>

<h2>使用Lisp构建博客系统</h2>

<p>要在VPS上安装软件，首先需要SSH上你的VPS，例如：ssh -p 1234
<a href="mailto:root@codemacro.com">root@codemacro.com</a>。</p>

<p>这里使用的软件集包括：</p>

<ul>
<li>nginx，Web服务器</li>
<li><a href="http://www.sbcl.org">SBCL</a> ，Lisp编译器实现</li>
<li><a href="http://www.quicklisp.org/">quicklisp</a> ，可以方便自动下载、安装Lisp库的工具</li>
<li><a href="http://weitz.de/hunchentoot/">hunchentoot</a>
，Lisp实现的Web服务器（不用特意安装）</li>
<li><a href="http://codemacro.com/view/8">ext-blog</a> ，Lisp实现的博客系统</li>
</ul>


<p>实际上，可以完全使用Lisp作为Web服务器，但我担心效率问题（对个人博客而言完全没这回事），所以使用了nginx作为Web服务器前端，将hunchentoot放在后面。</p>

<h3>安装nginx</h3>

<p>在设置好debian软件源后，安装非常简单:</p>

<pre><code>apt-get install nginx
</code></pre>

<p>安装完后，因为要将HTTP请求转发给Lisp服务器，所以需要修改下配置:</p>

<pre><code>vi /etc/nginx/sites-avaiable/default
</code></pre>

<p>将/请求派发给Lisp服务器（假设监听于8000端口）:</p>

<pre><code>location / {
    proxy_pass http://127.0.0.1:8000;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
}
</code></pre>

<p>然后可以启动nginx了:</p>

<pre><code>nginx
</code></pre>

<p>这个时候通过浏览器访问，会得到503 bad gateway的错误提示，因为hunchentoot还没开启。</p>

<h3>安装Lisp相关软件</h3>

<p><a href="http://www.sbcl.org">SBCL</a> 同样可以通过apt直接安装:</p>

<pre><code>apt-get instal sbcl
</code></pre>

<p>装好SBCL后，就可以进一步安装 <a href="http://www.quicklisp.org/">quicklisp</a>
。可以完全遵守quicklisp官方给的安装方法进行安装。大概就是先获取quicklisp.lisp文件，然后在SBCL中载入，根据提示即可。这里不再赘述。</p>

<p>安装好quicklisp后，就可以使用它安装很多Lisp软件/库了。quicklisp在安装一个Lisp库时，会自动下载并安装依赖库，就像apt-get一样。因为ext-blog并未收入到quicklisp的软件列表里，所以ext-blog需要手动安装。首先，在本地（非VPS上）获取ext-blog源码:</p>

<pre><code>git clone git://github.com/kevinlynx/ext-blog.git
</code></pre>

<p>进入到ext-blog目录。该目录下有几个方便的脚本可以用于博客管理。首先将ext-blog打包并上传到VPS上，例如:</p>

<pre><code>./upload-dist.sh root@codemacro.com 1234 /home/test
</code></pre>

<p>该脚本会调用make-dist.sh将ext-blog全部源码打包，然后使用scp拷贝该文件及update-blog.sh到VPS指定的目录里（这里是/home/test），然后ssh上VPS。期间会两次输入VPS系统的密码。然后以下操作将在VPS上完成。</p>

<p>首先进入到刚才拷贝文件的目录:</p>

<pre><code>cd /home/test
</code></pre>

<p>解压ext-blog.tar.gz:</p>

<pre><code>tar xvf ext-blog.tar.gz
</code></pre>

<p>然后ext-blog被解压到/home/test/dist目录。进入此目录运行SBCL:</p>

<pre><code>cd dist
sbcl
</code></pre>

<p>ext-blog目录下dep.lisp会使用quicklisp安装依赖库，进入SBCL后，载入该文件即可安装所有依赖库，这可能需要一点时间:</p>

<pre><code>(load "dep.lisp")
</code></pre>

<p>在没有其他问题下，可以暂时退出SBCL完成一些其他准备工作。</p>

<p>ext-blog在最近的版本中加入了验证码生成功能，这需要一个pcf字体文件。因为字体文件一般较大，所以upload-dist.sh脚本并没有将该字体文件打包，所以这里需要手动复制，同样在本地的ext-blog目录下:</p>

<pre><code>scp -P 1234 data/wenquanyi_12ptb.pcf root@codemacro.com:/home/test/dist/data/
</code></pre>

<p>另外，因为需要将Lisp解释器放置在系统后台执行，避免关掉SSH会话后终止SBCL进程，所以这里需要个工具gnu
screen。可以使用apt-get来安装:</p>

<pre><code>apt-get install screen
</code></pre>

<p>然后，一切就OK了。在VPS上可以使用ext-blog目录下的run-blog.sh来运行这个博客（首先确定VPS上的nginx开启）:</p>

<pre><code>./run-blog.sh
</code></pre>

<p>该脚本会使用screen在后台开启一个SBCL进程，并自动载入ext-blog，然后在8000端口上开启HTTP服务。这个启动过程可能会使用几十秒的时间，直接ctrl+z退出screen，这并不终止SBCL。一段时间后便可在浏览器里测试。</p>

<h3>设置博客</h3>

<p>如果一切正常，此时通过浏览器访问你的站点时，会被重定向到一个博客初始化页面，如下：</p>

<p><img src="/assets/res/build_blog/initblog.png" alt="image" /></p>

<p>上图中我是在本机测试的，所以域名是localhost，希望不至于产生误解。初始化仅需输入用户名和密码即可，以后可通过该用户名和密码进入博客后台管理页面。完成这一步后，就可以进入博客后台管理页面做更多的设置，例如博客标题等。</p>

<p>ext-blog的管理页面使用了emlog博客系统的CSS及其他资源，因此有同学觉得管理页面很面熟就不奇怪了。ext-blog提供在线编辑博客功能，同时也支持简单的metaweblog
API，因此可以使用一些博客客户端来发表文章（仅测过我自己写的博客客户端cl-writer）。</p>

<h2>最后</h2>

<p>本文描述较为粗略，主要是很多细节我自己也记不清。如有问题可以发邮件给我。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lisp实践：开发RSS阅读器]]></title>
    <link href="http://codemacro.com/2011/03/30/lisp-rss/"/>
    <updated>2011-03-30T00:00:00+08:00</updated>
    <id>http://codemacro.com/2011/03/30/lisp-rss</id>
    <content type="html"><![CDATA[<h1>一、RSS阅读器的实现</h1>

<p>RSS Reader的实现并不像它看上去那么复杂。当初在决定写这个作为Lisp练习时，甚至觉得
没有多少内容可做。其简单程度甚至用不了你启动一个慢速IDE的时间:D。对Lisp无兴趣的 TX只需要读完这一节即可，</p>

<!-- more -->


<h2>什么是RSS阅读器?</h2>

<p>RSS在实现上，可以说是XML的又一次扩张式的应用。因为RSS最重要的东西就是一个XML文件
。RSS主要用于Web中的内容同步。例如我们写的博客，门户网站的新闻，都是内容。Web服
务器将这些内容组织成XML，然后我们通过一个客户端来解析这些XML，就可以在不用直接访 问网站的情况下获取信息：
<img src="/assets/res/lisp_rss/rss-overview.png" alt="rss overview" /></p>

<p>RSS阅读器就是这样一个从Web服务器通过RSS（表现形式为XML）来获取信息内容的工具。它
可以被实现为一个独立的客户端程序，也可以实现为像Google Reader这种网页形式。后者
其核心功能其实是Google服务器在做，取得信息后再发给用户。</p>

<h2>RSS文件</h2>

<p>上已提及，RSS的实现其实就是个XML文件。这个XML文件格式非常简单，例如:</p>

<p><div class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="ni">&amp;lt;</span>?xml version=<span class="ni">&amp;ldquo;</span>1.0<span class="ni">&amp;rdquo;</span>?&gt;
<span class="nt">&lt;rss</span> <span class="na">version=</span><span class="s">&quot;2.0&quot;</span><span class="nt">&gt;</span>
   <span class="nt">&lt;channel&gt;</span>
      <span class="nt">&lt;title&gt;</span>Liftoff News<span class="nt">&lt;/title&gt;</span>
      <span class="nt">&lt;link&gt;&lt;a</span> <span class="na">href=</span><span class="s">&quot;http://liftoff.msfc.nasa.gov/&quot;</span><span class="nt">&gt;</span>http://liftoff.msfc.nasa.gov/<span class="nt">&lt;/a&gt;&lt;/link&gt;</span>
      <span class="nt">&lt;description&gt;</span>Liftoff to Space Exploration.<span class="nt">&lt;/description&gt;</span>
      <span class="nt">&lt;item&gt;</span>
         <span class="nt">&lt;title&gt;</span>Star City<span class="nt">&lt;/title&gt;</span>
         <span class="nt">&lt;link&gt;&lt;a</span> <span class="na">href=</span><span class="s">&quot;http://liftoff.msfc.nasa.gov/news/2003/news-starcity.asp&quot;</span><span class="nt">&gt;</span>http://liftoff.msfc.nasa.gov/news/2003/news-starcity.asp<span class="nt">&lt;/a&gt;&lt;/link&gt;</span>
         <span class="nt">&lt;description&gt;</span>Oh no, you wrote another blog!<span class="nt">&lt;/description&gt;</span>
      <span class="nt">&lt;/item&gt;</span>
    <span class="nt">&lt;/channel&gt;</span>
<span class="nt">&lt;/rss&gt;</span></code></pre></div></p>

<p>我们身边到处都是RSS文件，例如
<a href="http://www.cppblog.com/rss.aspx">http://www.cppblog.com/rss.aspx</a>
。RSS文件的框架大 致为:</p>

<pre><code>&lt;rss&gt;
    &lt;channel&gt;
        &lt;item&gt;
        &lt;/item&gt;
        &lt;item&gt;
        &lt;/item&gt;
        ...
    &lt;/channel&gt;
&lt;/rss&gt;
</code></pre>

<p>对，其框架就是这样，一个channel节点，其下若干个item节点。举例来说，
<strong>CPPBLOG首页就 是一个channel，该channel下有若干原创文章，每篇文章就是一个item。</strong> 无论是channel
，还是item，都会有很多属性，例如title/description/link，有些属性是RSS规范里要求
必须有的，有的是可选的。</p>

<h2>交互过程</h2>

<p>那么，服务器和客户端是如何交互的呢？首先，服务器上的程序针对其某个页面，生成对应
的RSS文件。这个RSS文件基本上是有固定的URL的。客户端每次获取内容时，就从这个固定
的URL获取这个RSS文件。客户端获取到这个RSS文件后，解析之，再呈现给用户。这就是整
个过程。这个过程中客户端与服务器的交互，全部是正常的HTTP请求。</p>

<p>而RSS阅读器，如果做得足够简单，则只需要从指定的地方获取到RSS文件，然后解析这个 XML文件，然后以相对友好的形式显示即可。</p>

<h2>扩展</h2>

<p>虽然RSS阅读器在核心功能上很简单，但是作为一个可以使用的工具，依然有很多功能点需 要实现。基本功能包括：</p>

<ul>
<li>记录用户关注的RSS</li>
<li>缓存某个RSS过去一段时间更新的内容</li>
<li>对HTTP回应的处理，最重要的就是重定向处理</li>
</ul>


<p>我们还可以做很多扩展，例如Google Reader之类的在线RSS阅读器。这些阅读器的RSS抓取
功能做在服务器端，它们除了上面提到的基础功能外，还会包含内容分类，给内容打一些 标签，分析用户的订阅习惯然后推荐类似的内容等等。</p>

<h1>二、Lisp实现</h1>

<p>本节描述在Lisp中实现上文的内容。主要包括： <strong>通过HTTP请求获取到RSS文件、解析RSS文件 。</strong></p>

<h2>获取RSS文件</h2>

<p>Lisp虽然历史悠久，但其扩展库标准却做得很拙劣。偏应用级的扩展库要么由编译器实现提
供，要么就得自己在网上找。一方面使用者希望库使用起来方便，另一方面库开发者在跨编 译器实现方面也头疼不已。所幸现在有了quick
lisp，安装第三方库就像Ubuntu里安装软件 一样简单（大部分）。</p>

<p>socket支持就是面临的第一个问题。不过我这里并不考虑跨编译器实现的问题，直接使用 SBCL里的socket接口。</p>

<p>要获取RSS文件，只需要连接Web服务器，发起HTTP的GET请求即可。当然，建立TCP连接，组
建HTTP请求包，就不是这里的讨论了。我们还是拿CPPBLOG首页的RSS为例，该RSS的URL为:</p>

<pre><code>http://www.cppblog.com/rss.aspx
</code></pre>

<p>拆分一下，得到host为www.cppblog.com（即我们要connect的地址），rss的uri为
/rss.aspx（即HTTP请求里的文件URI），于是建立HTTP请求包:</p>

<pre><code>GET /rss.aspx HTTP/1.0
Host: www.cppblog.com
</code></pre>

<p>关于HTTP请求的一些基础知识，可以参考我很早前写的一篇博客：&lt;<a href="http://www.cppblog.com/kevinlynx/archive/2008/07/30/57521.aspx">实现自己的http服务器</a>>。
正常情况下，Web服务器就会返回RSS的文件内容。然后我们就可以继续解析。</p>

<h2>解析RSS</h2>

<p>RSS本身是一个XML格式的文件。之前连接Web服务器发起HTTP请求没有用到第三方库，但是
解析XML文件不是几十来行代码能搞定的事情，所以这里需要选用一个第三方库。</p>

<p>我用的是s-xml，这个库在我之前的
<a href="http://www.cppblog.com/kevinlynx/archive/2011/03/13/141713.aspx">关于Lisp的文章</a>
中提到过。s-xml与我之前在C++ 领域见到的XML解析库最大的不同点在于，它提供的API是基于事件模式的。意思是说，你不
要去查询某个element的值是多少，当我解析到的时候会告诉你。事件模式的编程方式自然 离不开回调函数:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">s-xml:start-parse-xml</span>
  <span class="nc">stream</span>
  <span class="p">(</span><span class="nb">make-instance</span> <span class="nv">&amp;rsquo</span><span class="c1">;s-xml:xml-parser-state</span>
                 <span class="ss">:new-element-hook</span> <span class="err">#</span><span class="nv">&amp;lsquo</span><span class="c1">;decode-rss-new-element</span>
                 <span class="ss">:finish-element-hook</span> <span class="err">#</span><span class="nv">&amp;#8217</span><span class="c1">;decode-rss-finish-element</span>
                 <span class="ss">:text-hook</span> <span class="err">#</span><span class="nv">&amp;#8217</span><span class="c1">;decode-rss-text)))</span></code></pre></div></p>

<p>与s-xml交互的也就是上面代码里提到的三个函数：new-element-hook, finish-element-hook ,
text-hook。这种类型的接口导致解析代码大量减少，但不利于理解。我们要在整个解析
过程中传递数据，需要通过与s-xml交互的函数参数（当然不会蠢到去用全局变量）。</p>

<p>解析过程中通过往函数参数指定的对象身上塞数据完成，整个解析实现也就几十行代码。 文章尾可下载代码看看。</p>

<h2>显示出来</h2>

<p>通过上面两步，我们得到了RSS文件、解析出了具体内容，最后一步就是呈现出来看看。RSS
文件里每个Item都是一篇文章（新闻之类），这个文章内容可直接包含HTML标记，说白了，
这些内容就是直接的HTML内容。要显示这些内容，最简单的方法就是把一个RSS转换成一种 简单的HTML文件，以供阅读。</p>

<p>这里就涉及到HTML generator，几乎所有的Lisper都会写一个HTML产生器（库）（虽然目前
我还没写）。这种库的作用就是方便地输出HTML文件。</p>

<p>Lisp相对于其他语言很大的一个特点，或者说是优点，就是其语言本身的扩展能力。这种扩
展不是简单的添加几个函数，也不是类，而是提供一些就像语言本身提供的特殊操作符一样 的东西。而HTML
generator正是这种东西大放异彩的地方。这种感觉有点像在C++中通过模
板造出各种增强语言特性的东西一样（例如boost/loki）。</p>

<p>因为我这里只是输出简单的HTML文件，何况我对HTML的标记了解的也不多，也懒得再花经历 。所以我暂时也就将就了些土方法:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">with-output-to-string</span> <span class="p">(</span><span class="nc">stream</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">channel</span> <span class="p">(</span><span class="nv">rss-channel</span> <span class="nv">rss</span><span class="p">)))</span> <span class="c1">;取出channel对象</span>
   <span class="p">(</span><span class="nb">format</span> <span class="nc">stream</span> <span class="nv">&amp;ldquo</span><span class="c1">;&lt;html&gt;&lt;head&gt;&lt;title&gt;~a&lt;/title&gt;&lt;/head&gt;&amp;rdquo;</span>
           <span class="p">(</span><span class="nv">get-property</span> <span class="nv">channel</span> <span class="ss">:|title|</span><span class="p">))</span> <span class="c1">;取出channel的title</span></code></pre></div></p>

<p>最后组合一些接口，即可将整个过程联系起来，导出html文件:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">cl-rss-test:test-rss-http</span> <span class="ss">:uri</span> <span class="nv">&amp;ldquo</span><span class="c1">;/news/newshot/hotnewsrss.xml&amp;rdquo;</span>
                           <span class="ss">:host</span> <span class="nv">&amp;ldquo</span><span class="c1">;cd.qq.com&amp;rdquo;)</span></code></pre></div></p>

<p>然后在浏览器里查看，如图:</p>

<p><img src="/assets/res/lisp_rss/screenshot.png" alt="sample" /></p>

<h2>其他</h2>

<p>当一些代码可以工作起来的时候，就可以着手测试这批代码。然后我就用这个工具测试我 Google
Reader里订阅的一些RSS。最大的问题，就是关于HTTP重定向的问题。</p>

<p>当服务器返回301或者302的错误信息时（HTTP回应），就标示请求的URI被移动到了其他地 方，客户端需要访问新的地址。这个其实查查
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">HTTP的规范</a>
就可以轻易解决。重定向时， 新的URI被指定在Response Header里的Location域，取出来发起第二次请求即可。</p>

<p><a href="http://www.cppblog.com/Files/kevinlynx/cl-rss.tar.gz">下载代码</a></p>

<h1>参考文档</h1>

<ul>
<li>HTTP规范:
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http://www.w3.org/Protocols/rfc2616/rfc2616.html</a></li>
<li>RSS2.0规范:
<a href="http://feed2.w3.org/docs/rss2.html">http://feed2.w3.org/docs/rss2.html</a></li>
</ul>


<p>;;EOF;;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lisp一瞥：增强型变量Symbol]]></title>
    <link href="http://codemacro.com/2011/03/21/lisp-symbol/"/>
    <updated>2011-03-21T00:00:00+08:00</updated>
    <id>http://codemacro.com/2011/03/21/lisp-symbol</id>
    <content type="html"><![CDATA[<p>变量，是所有编程语言里都有的语法概念。在C/C++中，变量用于标示一个内存地址，而变
量名则在语法层面上代表这个地址。当链接器最终链接我们的程序时，就将这些名字替换
为实际的地址。在其他语言中，变量虽然或多或少有其他不同的含义，但也大致如此。</p>

<p>Lisp中的变量也差不多这样，但若将variable和Lisp中的 <strong>symbol</strong> 放在一起，则多少会 带来些困惑。</p>

<!-- more -->


<h2>Lisp中的“变量&#8221;</h2>

<p>很多教授Lisp的书中，大概会简单地告诉我们可以使用如下的方式定义一个全局变量 [1]_.
<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">defparameter</span> <span class="nv">&lt;em&gt;var&lt;/em&gt;</span> <span class="mi">1</span><span class="p">)</span></code></pre></div>
如上代码，我们便定义了一个全局变量 <code>*var*</code> [2]_ ，它被初始化为数值1。同样，我们 还可以使用另一种基本相同的方式:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">defvar</span> <span class="nv">&lt;em&gt;var&lt;/em&gt;</span> <span class="mi">1</span><span class="p">)</span></code></pre></div></p>

<p>除了全局变量，我们还可以定义局部变量。但局部变量的定义稍显麻烦（却可能是另一种
设计考虑）。定义局部变量需要使用一些宏，或者特殊运算符，例如:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">var</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="nv">&amp;ldquo</span><span class="c1">;~a&amp;rdquo; var))</span></code></pre></div></p>

<p>好了，就这些了。Lisp中关于变量的细节，也就这些。你甚至能用你在C/C++中的经验来窥
探一切。但是，我们很快就看到了很多困惑的地方。</p>

<p>我遇到的第一个困惑的地方来源于函数，那么等我讲讲函数再来分享下坎坷。</p>

<h2>Lisp中的函数</h2>

<p>Lisp中的函数绝对不复杂，你绝对不用担心我在忽悠你 [3]_ 。作为一门函数式语言，其首要
任务就是加强函数这个东西在整个语言里的功能。如果你喜欢广阅各种与你工作不相干的
技术，你肯定已经对很多函数式语言世界中的概念略有耳闻。例如闭包，以及first class type [4]_ 。</p>

<p>Lisp中的函数就是first class type。这什么意思呢？直白来说，
<strong>Lisp中的函数和变量 没什么区别，享有同等待遇</strong> 。进一步来说，变量fn的值可以是数值1，也可以是字符串
&ldquo;hello&#8221;，甚至是某个函数。这其实就是C++程序员说的functor。</p>

<p>Lisp中定义函数非常简单:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">add2</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="nv">x</span><span class="p">))</span></code></pre></div></p>

<p>这样，我们就定义了一个名为add2，有1个参数，1个返回值的函数。要调用该函数时，只需 要 <code>(add2 2)</code>
即可。这简直和我们在Lisp中完成一个加法一模一样:<code>(+ 2 3)</code></p>

<p>Lisp作为一门函数式语言，其函数也能作为另一个函数的参数和返回值 [5]_</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">apply-fn</span> <span class="p">(</span><span class="nv">fn</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">funcall</span> <span class="nv">fn</span> <span class="nv">x</span><span class="p">))</span></code></pre></div></p>

<p>apply-fn函数第一个参数是一个函数，它使用funcall函数间接地调用fn指向的函数。作为
一个C++程序员，这简直太好理解了，这完全就是一个函数指针的语法糖嘛。于是，假设我 们要使用apply-fn来间接调用add2函数:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">apply-fn</span> <span class="nv">add2</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">;; wrong</span></code></pre></div></p>

<p>可是这是不对的。我们需要通过另一个特殊操作符来完成这件事:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">apply-fn</span> <span class="err">#</span><span class="nv">&amp;lsquo</span><span class="c1">;add2 2) ;; right</span></code></pre></div></p>

<p>#&lsquo;操作符用于将add2对应的函数取出来，这么说当然不大准确。Again，作为一个C++程序员
，这简直就是个取地址操作符&amp;的语法糖嘛。好吧，这么理解起来似乎没问题了。</p>

<p>Lisp中能甚至能在任何地方定义一个函数，例如我们创建一个函数，该函数返回创建出来的 函数，这是一个典型的讲解什么是 <strong>闭包</strong>
的例子:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">get-add-n</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="err">#</span><span class="nv">&amp;lsquo</span><span class="c1">; (lambda (x)</span>
       <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">n</span><span class="p">)))</span></code></pre></div></p>

<p>无论如何，get-add-n函数返回一个函数，该函数是add2函数的泛型实现。它可以将你传入
的参数加上n。这些代码里使用了lambda表达式。lambda表达式直白来说，就是创建一个字
面上的函数。这又是什么意思呢？就像我们在代码中写出2，写出&#8221;hello&#8221;一样，2就是个字
面上的数字，&#8221;hello&#8221;就是个字面上的字符串 [6]_ 。</p>

<p>那么，总而言之，通过lambda创建一个函数体，然后通过#&lsquo;操作符即可得到一个函数，虽然 没有名字。有了以上知识后，Again
and again，作为一个C++程序员，很快我们就能得到一
个程序：定义变量，用变量去保存一个函数，然后通过这个变量来调用这个函数。这是多么
天经地义的事，就像之前那个通过参数调用其指向的函数一样:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="c1">;; wrong</span>
<span class="p">(</span><span class="nb">defvar</span> <span class="nv">fn</span> <span class="err">#</span><span class="nv">&amp;lsquo</span><span class="c1">; (lambda (x) (+ x 2)))</span>
<span class="p">(</span><span class="nv">fn</span> <span class="mi">3</span><span class="p">)</span></code></pre></div></p>

<p>这样的代码是不对的，错误发生于第二行，无论你使用的Lisp实现是哪种，大概会得到如下 的错误信息:</p>

<pre><code>"The function FN is undefined."
</code></pre>

<p>老实说，这已经算是多么有迹可循的错误提示了啊。将以上代码和之前的apply-fn对比，是
多么得神似啊，可惜就是错的。这是我们遇到的第一个理解偏差导致的问题。如果你还不深
入探究，你将会在这一块遇到更多麻烦。及时地拿出你的勇气，披荆斩棘，刨根究底，绝对 是学习编程的好品质。</p>

<h2>“万恶之源“：SYMBOL</h2>

<p>上文中提到的变量函数之类，之所以会在某些时候与我们的理解发生偏差，并且总是存在些
神秘的地方无法解释。这完全是因为我们理解得太片面导致。Lisp中的Symbol可以说就是某
个变量，或者某个函数，但这太片面。Lisp中的Symbol拥有更丰富的含义。</p>

<h3>Symbol的名字</h3>

<p>就像很多语言的变量、函数名一样，Lisp中的Symbol比其他语言在命名方面更自由：
<strong>只 要位于&#8217;|&lsquo;字符之间的字符串，就表示一个合法的Symbol名。</strong> 我们可以使用函数
symbol-name来获取一个Symbol的名字，例如:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">symbol-name</span> <span class="nv">&amp;lsquo</span><span class="c1">;|this is a symbol name|)</span></code></pre></div></p>

<pre><code>输出："this is a symbol name"
</code></pre>

<p>&lsquo;(quote)操作符告诉Lisp不要对其修饰的东西进行求值(evaluate)。但假如没有这个操作符
会怎样呢？后面我们将看到会怎样。</p>

<h3>Symbol本质</h3>

<p><ANSI Common Lisp\>一书中有句话真正地揭示了Symbol的本质：
<strong>Symbols are real objects</strong>
。是的，Symbols是对象，这个对象就像我们理解的C++中的对象一样，它是一个
复合的数据结构。该数据结构里包含若干域，或者通俗而言：数据成员。借用<ANSI Common Lisp\>中的一图：</p>

<blockquote><p><img src="/assets/res/lisp_symbol/symbol-obj.png" alt="image" /></p></blockquote>

<p>通过这幅图，可以揭开所有谜底。一个Symbol包含至少图中的几个域，例如Name、Value、
Function等。在Lisp中有很多函数来访问这些域，例如上文中使用到的symbol-name，这个
函数本质上就是取出一个Symbol的Name域。</p>

<h3>Symbol与Variable和Function的联系</h3>

<p>自然而然地，翻阅Lisp文档，我们会发现果然还有其他函数来访问Symbol的其他域，例如:</p>

<pre><code>symbol-function
symbol-value
symbol-package
symbol-plist
</code></pre>

<p>但是这些又与上文提到的变量和函数有什么联系呢？真相只有一个，
<strong>变量、函数粗略来 说就是Symbol的一个域，一个成员。变量对应Value域，函数对应Function域。一个Symbol 这些域有数据了，我们说它们发生了绑定(bind)。</strong>
而恰好，我们有几个函数可以用于判 定这些域是否被绑定了值:</p>

<pre><code>boundp ;判定Value域是否被绑定
fboundp;判定Function域是否被绑定
</code></pre>

<p>通过一些代码来回味以上结论:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">defvar</span> <span class="nv">&lt;em&gt;var&lt;/em&gt;</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="nb">boundp</span> <span class="nv">&amp;lsquo</span><span class="c1">;&lt;em&gt;var&lt;/em&gt;) ; 返回真</span>
<span class="p">(</span><span class="nb">fboundp</span> <span class="nv">&amp;rsquo</span><span class="c1">;&lt;em&gt;var&lt;/em&gt;) ; 返回假</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">&lt;em&gt;var&lt;/em&gt;</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span> <span class="c1">; 定义一个名为&lt;em&gt;var&lt;/em&gt;的函数，返回值即为参数</span>
<span class="p">(</span><span class="nb">fboundp</span> <span class="nv">&amp;lsquo</span><span class="c1">;&lt;em&gt;var&lt;/em&gt;) ; 返回真</span></code></pre></div></p>

<p>上面的代码简直揭秘了若干惊天地泣鬼神的真相。首先，我们使用我们熟知的defvar定义了 一个名为 <code>*var*</code>
的变量，初值为1，然后使用boundp去判定 <code>*var*</code> 的Value域是否 发生了绑定。这其实是说：
<strong>原来定义变量就是定义了一个Symbol，给变量赋值，原来就 是给Symbol的Value域赋值！</strong></p>

<p><strong>其实，Lisp中所有这些符号，都是Symbol。</strong> 什么变量，什么函数，都是浮云。上面的
例子中，紧接着用fboundp判断Symbol <code>*var*</code> 的Function域是否绑定，这个时候为假。 然后我们定义了一个名为
<code>*var*</code> 的函数，之后再判断，则已然为真。这也是为什么， <strong>在Lisp中某个函数可以和某个变量同名的原因所在。</strong>
从这段代码中我们也可以看出 defvar/defun这些操作符、宏所做事情的本质。</p>

<h3>More More More</h3>

<p>事情就这样结束了？Of course not。还有很多上文提到的疑惑没有解决。首先，Symbol是
如此复杂，那么Lisp如何决定它在不同环境下的含义呢？Symbol虽然是个对象，但它并不像
C++中的对象一样，它出现时并不指代自己！不同应用环境下，它指代的东西也不一样。这 些指代主要包括变量和函数，意思是说：
<strong>Symbol出现时，要么指的是它的Value，要么是 它的Function。</strong> 这种背地里干的事情，也算是造成迷惑的一个原因。</p>

<p>当一个Symbol出现在一个List的第一个元素时，它被处理为函数。这么说有点迷惑人，因为
它带进了Lisp中代码和数据之间的模糊边界特性。简单来说，就是当Symbol出现在一个括号
表达式(s-expression)中第一个位置时，算是个函数，例如:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">add2</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; add2位于第一个位置，被当作函数处理</span>
<span class="p">(</span><span class="nv">&lt;em&gt;var&lt;/em&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; 这里&lt;em&gt;var&lt;/em&gt;被当作函数调用，返回3</span></code></pre></div></p>

<p>除此之外，我能想到的其他大部分情况，一个Symbol都被指代为它的Value域，也就是被当 作变量，例如:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">&lt;em&gt;var&lt;/em&gt;</span> <span class="nv">&lt;em&gt;var&lt;/em&gt;</span><span class="p">)</span> <span class="c1">; 这是正确的语句，返回1</span></code></pre></div></p>

<p>这看起来是多么古怪的代码。但是运用我们上面说的结论，便可轻易解释：表达式中第一个 <code>*var*</code>
被当作函数处理，它需要一个参数；表达式第二部分的 <code>*var*</code> 被当作变量 处理，它的值为1，然后将其作为参数传入。</p>

<p>再来说说&#8217;(quote)操作符，这个操作符用于防止其操作数被求值。而当一个Symbol出现时，
它总是会被求值，所以，我们可以分析以下代码:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">symbol-value</span> <span class="nv">&lt;em&gt;var&lt;/em&gt;</span><span class="p">)</span> <span class="c1">; wrong</span></code></pre></div></p>

<p>这个代码并不正确，因为 <code>*var*</code> 总是会被求值，就像 <code>(*var* *var*)</code> 一样，第二 个 <code>*var*</code>
被求值，得到数字1。这里也会发生这种事情，那么最终就等同于:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">symbol-value</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">; wrong</span></code></pre></div></p>

<p>我们试图去取数字1的Value域，而数字1并不是一个Symbol。所以，我们需要quote运算符:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">symbol-value</span> <span class="nv">&amp;lsquo</span><span class="c1">;&lt;em&gt;var&lt;/em&gt;) ; right</span></code></pre></div></p>

<p>这句代码是说，取Symbol <code>*var*</code> 本身的Value域！而不是其他什么地方。至此，我们 便可以分析以下复杂情况:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">defvar</span> <span class="nv">&lt;em&gt;name&lt;/em&gt;</span> <span class="nv">&amp;ldquo</span><span class="c1">;kevin lynx&amp;rdquo;)</span>
<span class="p">(</span><span class="nb">defvar</span> <span class="nv">&lt;em&gt;ref&lt;/em&gt;</span> <span class="nv">&amp;lsquo</span><span class="c1">;&lt;em&gt;name&lt;/em&gt;) ; &lt;em&gt;ref&lt;/em&gt;的Value保存的是另一个Symbol</span>
<span class="p">(</span><span class="nb">symbol-value</span> <span class="nv">&lt;em&gt;ref&lt;/em&gt;</span><span class="p">)</span> <span class="c1">; 取&lt;em&gt;ref&lt;/em&gt;的Value，得到&lt;em&gt;name&lt;/em&gt;，再取&lt;em&gt;name&lt;/em&gt;的Value</span></code></pre></div></p>

<p>现在，我们甚至能解释上文留下的一个问题:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="c1">;; wrong</span>
<span class="p">(</span><span class="nb">defvar</span> <span class="nv">fn</span> <span class="err">#</span><span class="nv">&amp;lsquo</span><span class="c1">; (lambda (x) (+ x 2)))</span>
<span class="p">(</span><span class="nv">fn</span> <span class="mi">3</span><span class="p">)</span></code></pre></div></p>

<p>给fn的Value赋值一个函数， <code>(fn 3)</code> 当一个Symbol作为函数使用时，也就是取其
Function域来做调用。但其Function域什么也没有，我们试图将一个Symbol的Value域当作
Function来使用。如何解决这个问题？想想，symbol-function可以取到一个Symbol的 Function域:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">symbol-function</span> <span class="nv">&amp;lsquo</span><span class="c1">;fn) #&amp;rsquo; (lambda (x) (+ x 2)))</span>
<span class="p">(</span><span class="nv">fn</span> <span class="mi">3</span><span class="p">)</span></code></pre></div></p>

<p>通过显示地给fn的Function域赋值，而不是通过defvar隐式地对其Value域赋值，就可以使 <code>(fn 3)</code>
调用正确。还有另一个问题也能轻易解释:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">apply-fn</span> <span class="nv">add2</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">; wrong</span></code></pre></div></p>

<p>本意是想传入add2这个Symbol的function域，但是直接这样写的话，传入的其实是add2的 Value域 [7]_
，这当然是不正确的。对比正确的写法，我们甚至能猜测#&lsquo;运算符就是一个
取Symbol的Function域的运算符。进一步，我们还可以给出另一种写法:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">apply-fn</span> <span class="p">(</span><span class="nb">symbol-function</span> <span class="nv">&amp;lsquo</span><span class="c1">;add2) 2)</span></code></pre></div></p>

<p>深入理解事情的背后，你会发现你能写出多么灵活的代码。</p>

<h2>END</h2>

<p>关于Symbol的内容还有更多，例如Package。正确理解这些内容以及他们之间的关系，有助 于更深刻地理解Lisp。</p>

<h2>注解</h2>

<ul>
<li>[1]  在Lisp中全局变量又被称为dynamic variables</li>
<li>[2]  Lisp中按照习惯通常在为全局变量命名时会加上星号，就像我们习惯使用g_一样</li>
<li>[3]  因为我确实在忽悠你</li>
<li>[4]  first class type，有人翻译为“一等公民”，我觉得压力巨大</li>
<li>[5]  即高阶函数</li>
<li>[6]  “字面“主要是针对这些信息会被词法分析程序直接处理</li>
<li>[7]  这可能导致更多的错误</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用lisp开发博客客户端]]></title>
    <link href="http://codemacro.com/2011/03/13/lisp-writer/"/>
    <updated>2011-03-13T00:00:00+08:00</updated>
    <id>http://codemacro.com/2011/03/13/lisp-writer</id>
    <content type="html"><![CDATA[<p>最近一直在学习Lisp这门语言。回头一看，基本上接近1个月了。刚开始接触Lisp是因为看
了&lt;Lisp本质&gt;，然后我发现有很多人宗教般地忠诚这门语言，于是就来了兴趣。</p>

<p><img src="/assets/res/lisp_writer/lisp_believer.png" alt="lisp_believer" /></p>

<p>当然并不是每次因为某篇写得很geek技术文章就去学习某个新的技术点。一个月时间对我来
说还是很珍贵了。但是Lisp绝对是大部分程序员都值得一学的语言（就像Haskell一样）。
我能给出的简单理由包括：</p>

<!-- more -->


<ul>
<li>大部分程序员只会命令式语言（C/C++/C Like etc)，缺乏函数式语言解决编程问题的思
想（当然Lisp不是纯函数式)</li>
<li>Lisp是仅次于Fortran的古老语言，很多优秀的语言设计思想在现代的一些语言里都找得
到</li>
<li>装B党必备</li>
</ul>


<p>另一方面，结合我一个月以来的读书和两个练习工程的实践经历，我觉得也有些理由值得你
不去学习Lisp：</p>

<ul>
<li>你会Haskell或者其他函数式语言</li>
<li>我目前还是觉得Lisp学习曲线高(大概是因为我读到的书都在应用语法层兜圈子，事实上
Lisp的语法之统一，全特么的是s-expression)，你不愿意花费这些成本</li>
<li>you are too old bo to be a B</li>
</ul>


<h2>关于这篇文档</h2>

<p>这篇博客我使用reStructuredText格式编写，然后用docutls导出为html，再然后使用这回
用lisp开发的基于metaweblog API的博客客户端，自动发布到CPPBLOG。</p>

<h2>他们怎么说Lisp</h2>

<p>我就摘录些书上的观点(历史)：</p>

<ul>
<li>1958年，John McCarthy和他的学生搞出了Lisp，包括其第一个实现，最初貌似也是以一
篇论文起头</li>
<li>Lisp可以让你做其他语言里无法做的事情(&lt;ANSI common Lisp&gt;)</li>
<li>大部分编程语言只会告诉你不能怎样做，这限制了你解决问题的思路，Lisp not (&lt;ANSI
Common Lisp&gt;)</li>
<li>Lisp让你以Lisp的思维思考问题，换到其他语言你会说：为什么X语言就不支持这个特性
呢(Once you&rsquo;ve leanred Lisp, you&rsquo;ll even dream in Lisp) (&lt;Land Of Lisp&gt;)</li>
<li>Lisp代码更清晰地体现你的想法(&lt;Practical Common Lisp&gt;)</li>
</ul>


<h2>And my opinion</h2>

<p>我可还没到把Lisp捧上天的地步。如果Lisp如此之好，为什么用的人不多？&lt;Land Of Lisp&gt;
里作者恰好对这个问题做了回答(bla bla bla，懒得细读)。</p>

<ul>
<li>Lisp也是一门杂和型风格的语言，函数式、命令式、面向对象，以及最被人吹捧的宏编程
&ndash;程序自己写自己</li>
<li>Lisp的语句全部以(xxx xxx)的形式出现，被称为s-expression，我看称为括号表达式还
差不多</li>
<li>Lisp每条语句都有返回值，没基础过函数式编程的同学，if语句也是有返回值的</li>
<li>函数式编程语言的一个重要特性就是闭包(closure)，这个东西用来避免全局变量实在太
geek了</li>
</ul>


<h2>开始学习Lisp</h2>

<p>Lisp不像有些语言，有个直接的机构来维护。感觉它更像C/C++一样，只有个标准，然后有
若干编译器（解释器）实现。Lisp在几十年的发展中，产生了很多种方言。方言也就是形变
神不变的语言变种，本文说的Lisp均指Lisp的方言Common Lisp。另一个比较有名的方言是
Scheme，关于各个方言的特点，&lt;Land Of Lisp&gt;里也给了一个图片：</p>

<p><img src="/assets/res/lisp_writer/dialect.png" alt="dialect" /></p>

<p>其中，最左边那只wolf就是Common Lisp，右边那只sheep就是Scheme。</p>

<p>要学习Lisp，首先就是选择方言。然后最重要的就是选择一个编译器实现。世界上知名的有
十几种实现（也许更多）。一些商业版本非常强大，甚至能编译出很小的本地代码执行文件
，不过价格也不菲。当然也有很多开源免费的实现，例如CLISP、SBCL。我选用的是SBCL。</p>

<p>SBCL交互式命令行不支持括号匹配，甚至没有输入历史。要实现这两个功能，可以装一个
lisp工具：linedit。在lisp的世界中，要获得一个lisp的库实在不是件方便的事。尤其是
这些免费的编译器实现，并不像有些语言一样，直接随编译器带个几十M的库。</p>

<p>然后就有了quicklisp这个工具。该工具就像Ubuntu系统里的软件管理器一样，你可以在
lisp里直接获取某个库。quicklisp检查该库是否存在，不存在直接从它的服务器上下载人
然后自动安装。</p>

<p>此外，在lisp的世界里，写出来的程序不再是跨OS。OS的差异由编译器实现来解决。但是，
写lisp程序却需要考虑跨编译器实现（egg hurt）。这也是个无比伤神的事，比跨OS更伤
神。因为OS就那么几个，但lisp的编译器实现，流行的也有好几个。</p>

<p>lisp的世界里，工程组织也有特殊的一套，就像makefile一样，这就是asdf。</p>

<h2>博客客户端如何实现</h2>

<p>像我们这种基本没接触过Web开发的人，可能完全没有思路去实现一个博客客户端。事实上
实现起来非常简单。</p>

<p>使用过其他博客客户端（例如Windows Live writer）的人肯定知道metaweblog API，在配
置客户端的时候需要填入。例如CPPBLOG的这个地址就是
<a href="http://www.cppblog.com/kevinlynx/services/metaweblog.aspx%E3%80%82%E8%BF%99%E4%B8%AA%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E4%BA%86%E4%B8%80%E4%BA%9BAPI">http://www.cppblog.com/kevinlynx/services/metaweblog.aspx%E3%80%82%E8%BF%99%E4%B8%AA%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E4%BA%86%E4%B8%80%E4%BA%9BAPI</a>
说明。这些API就是博客客户端和服务器进行操作通信的接口。意思是说，服务器端提供这
这些接口，我们的客户端调用这些接口即可。例如:</p>

<pre><code>blogger.deletePost，调用该接口即可删除一篇博客文章
</code></pre>

<p>但是客户端如何调用到这个接口呢？这需要通过一种新的技术（或者说标准），即 <strong>xml rpc</strong>
。rpc大家应该清楚，xml rpc其实说白了， <strong>就是把接口调用的细则塞进</strong> <strong>http
请求发给web服务器，服务器接收请求完成操作后再把结果以http回应的形式丢给客户端，
即完成了一次接口调用</strong> 。</p>

<p>至于http请求回应的细则就不提了，无非就是一些特殊格式的数据，通过tcp连接与服务器
交互这些数据。</p>

<p>所以，基本上，整个过程还是非常简单。如何来将调用细节塞进http请求，则是以xml rpc
标准来做，其格式正好是xml格式。举个例子吧:</p>

<p><div class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="ni">&amp;lt;</span>?xml version=<span class="ni">&amp;lsquo;</span>1.0<span class="ni">&amp;rsquo;</span>?&gt;
<span class="nt">&lt;methodCall&gt;</span>
    <span class="nt">&lt;methodName&gt;</span>title_or_id<span class="nt">&lt;/methodName&gt;</span>
        <span class="nt">&lt;params&gt;</span>
        <span class="nt">&lt;/params&gt;</span>
<span class="nt">&lt;/methodCall&gt;</span></code></pre></div></p>

<p>当然这部分数据之前就是若干http请求的数据。服务器回应也是以xml格式组织:</p>

<p><div class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="ni">&amp;lt;</span>?xml version=<span class="ni">&amp;lsquo;</span>1.0<span class="ni">&amp;rsquo;</span>?&gt;
<span class="nt">&lt;methodResponse&gt;</span>
    <span class="nt">&lt;params&gt;</span>
        <span class="nt">&lt;param&gt;</span>
            <span class="nt">&lt;value&gt;&lt;string&gt;</span>Welcome to Zope.org<span class="nt">&lt;/string&gt;&lt;/value&gt;</span>
        <span class="nt">&lt;/param&gt;</span>
    <span class="nt">&lt;/params&gt;</span>
<span class="nt">&lt;/methodResponse&gt;</span></code></pre></div></p>

<p>我们的博客客户端所要做的，就是把这些博客发布相关的操作封装起来提供给使用者。底层
实现主要包括http请求、xml-rpc的组织等。何况，这两部分在各个语言里都有大量的库存
在，lisp自然也有。</p>

<p>我这里直接选取了lisp的一个xml-rpc库：s-xml-rpc，基本上百来行代码就可以把各个功
能跑一遍。例如以下lisp代码就实现了通过s-xml-rpc删除CPPBLOG的一篇文章:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">delete-post</span> <span class="p">(</span><span class="nv">postid</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">rpc-call</span>
    <span class="nv">&amp;ldquo</span><span class="c1">;blogger.deletePost&amp;rdquo;</span>
    <span class="nv">postid</span>
    <span class="nv">&amp;ldquo</span><span class="c1">;kevinlynx&amp;rdquo;</span>
    <span class="nv">&amp;ldquo</span><span class="c1">;password&amp;rdquo;</span>
    <span class="no">t</span><span class="p">))</span></code></pre></div></p>

<p>发布博客也很简单，根据metaweblog API接口的说明，发布博客时需要填充一个结构体。但
主要涉及到的数据仅包括：文章内容、文章标题、文章分类（可选）:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">new-post</span> <span class="p">(</span><span class="nv">title</span> <span class="nv">context</span> <span class="nv">&amp;amp</span><span class="c1">;optional (cates))</span>
  <span class="p">(</span><span class="nv">rpc-call</span>
    <span class="nv">&amp;ldquo</span><span class="c1">;metaWeblog.newPost&amp;rdquo;</span>
    <span class="nv">&amp;ldquo</span><span class="c1">;&amp;rdquo;</span>
    <span class="nv">&amp;ldquo</span><span class="c1">;kevinlynx&amp;rdquo;</span>
    <span class="nv">&amp;ldquo</span><span class="c1">;password&amp;rdquo;</span>
    <span class="p">(</span><span class="nv">new-post-struct</span> <span class="nv">title</span> <span class="nv">context</span> <span class="nv">cates</span><span class="p">)</span>
    <span class="no">t</span><span class="p">))</span></code></pre></div></p>

<p>值得注意的是，如果文章中有贴图，则需要事先将图片文件上传到服务器。CPPBLOG的
metaweblog API里恰有API提供:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">new-media-object</span> <span class="p">(</span><span class="nv">filename</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">rpc-call</span>
    <span class="nv">&amp;ldquo</span><span class="c1">;metaWeblog.newMediaObject&amp;rdquo;</span>
    <span class="nv">&amp;ldquo</span><span class="c1">;&amp;rdquo;</span>
    <span class="nv">&amp;ldquo</span><span class="c1">;kevinlynx&amp;rdquo;</span>
    <span class="nv">&amp;ldquo</span><span class="c1">;password&amp;rdquo;</span>
    <span class="p">(</span><span class="nv">new-media-object-struct</span> <span class="nv">filename</span><span class="p">)))</span></code></pre></div></p>

<p>该函数读入图片文件，然后调用metaWeblog.newMediaObject接口，即可完成上传。上传成
功后，服务器会返回该图片的URL。然后在我们的文章中就可以使用该图片了。</p>

<h2>完整实现方案</h2>

<p>仅仅将metaweblog的一些接口做封装，对于一个可以使用的博客客户端来说还远远不够。大
部分同类工具都有一个友好的GUI编辑界面。我并不打算弄一个编辑界面出来，吃力不讨好
的事情。</p>

<p>我的打算是先用其他工具对文章做排版处理，最后导出为html格式。因为CPPBLOG支持直接
发布一个html文件。然后在用这个lisp工具将整个文件作为博客文章内容发布。</p>

<p>恰好公司最近打算用reStructureText(rst)格式来编辑文档，作为熟悉手段，我决定拿这个
来练手。rst格式非常简单，同wiki命令很相似。在vim里编辑该文件非常合适，因为默认支
持。见图:</p>

<p><img src="/assets/res/lisp_writer/rst.png" alt="rst_sample" /></p>

<p>由图即可看出，rst是一种半所见即所得的格式。即：它遵循你在编辑器里的排版，同时也
通过一些tag（例如image）来控制更丰富的输出。</p>

<p>rst有很多前端工具，可以将rst文件输出，例如rst2html.py就可以输出为html。好吧，最
最终我们得到了html格式的博客文章。</p>

<p>但是如果文章中出现了图片，而图片基本上在本地，转成html后也是相对路径。我需要我的
lisp writer(cl-writer)能自动扫描文章，发现有图片的地方，就自动将图片上传。最恶心
的是上传后还得替换图片引用路径。这个工作可以在rst格式上做，也可以在结果格式html
上做。通过xml解析库解析html比直接解析rst格式更简单，并且在扩展性上更好。</p>

<p>最终这个html中图片路径替换工作只消耗了不到100行lisp代码。这在很大程度上也依赖于
s-xml库的接口设计。</p>

<p>最终封装好的发布接口如下，从这里也可以看出，函数式语言锻炼我们写出功能单一代码度
短小的接口:</p>

<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">writer-post-new</span> <span class="p">(</span><span class="nv">post-file</span> <span class="nv">&amp;amp</span><span class="c1">;key (u (get-default-user))(cates))</span>
  <span class="p">(</span><span class="nv">read-post-file</span> <span class="nv">u</span> <span class="nv">post-file</span> <span class="nv">context</span> <span class="nv">title</span>
                  <span class="p">(</span><span class="nv">new-post</span> <span class="nv">u</span> <span class="nv">title</span> <span class="nv">context</span> <span class="nv">cates</span><span class="p">)))</span></code></pre></div></p>

<h2>END</h2>

<p>别指望我发布的代码能够让你一键在你的博客上留下&#8221;this is a test&#8221;，你甚至别指望它能
能够工作。但如果你本来就是一个资深的lisper，或者虽然不是lisper但却执意想看看结果
。这里我就简要说说如何让这些代码欢乐起来:</p>

<ul>
<li>OS Ubuntu10.04，下载安装SBCL，不会有问题；</li>
<li>下载安装quicklisp，官方文档hand by hand，简单不会有问题；</li>
<li><p>SBCL交互环境中使用quicklisp安装s-xml-rpc:</p>

<p> <div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">ql:quickload</span> <span class="nv">&amp;ldquo</span><span class="c1">;s-xml-rpc&amp;rdquo;)</span></code></pre></div></p></li>
<li><p>装载我的代码:</p>

<p> <div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">asdf:load-system</span> <span class="ss">:cl-writer</span><span class="p">)</span></code></pre></div></p></li>
<li><p>在home下添加配置文件.cl-writer.lisp，配置你博客信息，例如:</p></li>
</ul>


<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">in-package</span> <span class="nv">cl-writer</span><span class="p">)</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">&lt;em&gt;default-user&lt;/em&gt;</span> <span class="p">(</span><span class="nv">make-cppblog-user</span> <span class="nv">&amp;ldquo</span><span class="c1">;账户名&amp;rdquo; &amp;ldquo;密码&amp;rdquo;))</span></code></pre></div></p>

<ul>
<li>SBCL交互环境下测试:</li>
</ul>


<p><div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">in-package</span> <span class="nv">cl-writer</span><span class="p">)</span>
<span class="p">(</span><span class="nv">new-post</span> <span class="p">(</span><span class="nv">get-default-user</span><span class="p">)</span> <span class="nv">&amp;ldquo</span><span class="c1">;this is a test&amp;rdquo; &amp;ldquo;title&amp;rdquo;)</span></code></pre></div></p>

<p><a href="http://www.cppblog.com/Files/kevinlynx/cl-writer.tar.gz">下载代码</a></p>

<p>最后，终于敲完这篇文章，我需要通过以下步骤来发表它:</p>

<pre><code>in shell:

rst2html.py lisp_xml_rpc.rst lisp_xml_rpc.html

in SBCL:

(writer-post-new "lisp_xml_rpc.html")
</code></pre>

<p>EOF</p>
]]></content>
  </entry>
  
</feed>
